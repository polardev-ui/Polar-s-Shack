<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8NN9RRBJ8H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8NN9RRBJ8H');
</script>
  <meta charset="utf-8" />
  <title>Polar's Shack — Chat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="../logo.png">
  <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
:root {
  --bg:#111;
  --card:#1e1e1e;
  --muted:#666;
  --accent:#00ff00;
  --danger:#ff6666;
  --panel:#0f0f0f;
  --border:#333;
}
* { box-sizing: border-box; margin:0; padding:0; }
body {
  font-family:'JetBrains Mono', monospace;
  background:linear-gradient(180deg,#0b0b0b,var(--bg));
  color:#ddd;
  height:100vh;
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

/* Enhanced navbar with settings button */
.navbar {
  background:#1a1a1a;
  padding:1rem 1.5rem;
  border-bottom:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  position:sticky;
  top:0;
  z-index:60;
  backdrop-filter:blur(10px);
}
.logo-nav {display:flex;gap:.75rem;align-items:center;}
.logo-nav img {width:34px;height:34px;border-radius:6px;}
.logo-nav span {color:#fff;font-weight:600;font-size:1.1rem;}
.nav-links {display:flex;gap:1.5rem;align-items:center;}
.nav-links a {color:#aaa;text-decoration:none;padding:.4rem .6rem;border-radius:6px;transition:all .2s;}
.nav-links a.active, .nav-links a:hover {color:var(--accent);background:rgba(0,255,0,0.05);}
.nav-btn {background:#2a2a2a;border:1px solid var(--border);color:#aaa;padding:.5rem .9rem;border-radius:8px;cursor:pointer;transition:all .2s;font-family:'JetBrains Mono',monospace;font-size:.9rem;display:flex;align-items:center;gap:.5rem;}
.nav-btn:hover {background:#333;border-color:var(--accent);color:var(--accent);}

/* Three-column layout: users | chat | room-selector */
.layout {
  display:flex;
  height:calc(100vh - 70px);
  width:100%;
  overflow:hidden;
}

/* Users panel with profile click */
.users-panel {
  width:240px;
  background:var(--panel);
  border-right:1px solid var(--border);
  padding:.75rem;
  overflow-y:auto;
  box-shadow:0 6px 18px rgba(0,0,0,0.5);
}
.users-panel h3 {color:var(--accent);margin:.15rem 0 .75rem;font-size:1rem;text-transform:uppercase;letter-spacing:1px;}
.user-row {
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .7rem;
  border-radius:8px;
  transition:all .15s;
  cursor:pointer;
  border:1px solid transparent;
}
.user-row:hover {background:#151515;transform:translateY(-1px);border-color:var(--accent);}
.user-name {
  color:#fff;
  font-weight:600;
  font-size:.95rem;
  max-width:140px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.user-meta {font-size:.75rem;color:var(--muted);}
.badge-admin {color:var(--danger);font-weight:700;margin-left:.4rem;font-size:.75rem;}
.status-dot {
  width:8px;
  height:8px;
  border-radius:50%;
  display:inline-block;
  margin-right:.4rem;
}
.status-dot.online {background:var(--accent);box-shadow:0 0 8px var(--accent);}
.status-dot.offline {background:#444;}

/* Chat card with room switcher */
.chat-card {
  flex:1;
  display:flex;
  flex-direction:column;
  background:linear-gradient(180deg,#121212,#161616);
  border-left:1px solid var(--border);
  overflow:hidden;
  box-shadow:0 10px 30px rgba(0,0,0,0.6);
}
.chat-header {
  padding:1rem 1.25rem;
  border-bottom:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:1rem;
  background:#1a1a1a;
}
.chat-header .title {color:var(--accent);font-weight:700;font-size:1.1rem;}
.chat-header .right {font-size:.9rem;color:var(--muted);display:flex;gap:.75rem;align-items:center;}

/* gray icon button (matches nav-btn aesthetic but compact) */
.icon-btn {
  background:#2a2a2a;
  border:1px solid var(--border);
  color:#aaa;
  padding:.45rem .6rem;
  border-radius:8px;
  cursor:pointer;
  transition:all .2s;
  display:flex;
  align-items:center;
  gap:.4rem;
}
.icon-btn:hover {background:#333;border-color:var(--accent);color:var(--accent);} 
/* typing indicator styling */
#typingDot { color: var(--accent); opacity:.8; animation: typingBlink 1s ease-in-out infinite; }
@keyframes typingBlink { 0%{opacity:.35} 50%{opacity:1} 100%{opacity:.35} }

/* Room selector tabs */
.room-tabs {
  display:flex;
  gap:.5rem;
  padding:.75rem 1rem;
  background:#0f0f0f;
  border-bottom:1px solid var(--border);
  overflow-x:auto;
}
.room-tab {
  padding:.5rem 1rem;
  background:#2a2a2a;
  border:1px solid var(--border);
  border-radius:8px;
  color:#888;
  cursor:pointer;
  transition:all .2s;
  white-space:nowrap;
  font-size:.85rem;
  display:flex;
  align-items:center;
  gap:.5rem;
}
.room-tab.active {background:var(--accent);color:#000;border-color:var(--accent);font-weight:600;}
.room-tab:hover:not(.active) {background:#333;border-color:var(--accent);color:var(--accent);}
.room-tab .close-dm {
  margin-left:.3rem;
  opacity:.6;
  transition:opacity .2s;
}
.room-tab .close-dm:hover {opacity:1;}

/* Messages with reply support */
.messages {
  flex:1;
  padding:1rem;
  overflow-y:auto;
  display:flex;
  flex-direction:column;
  gap:.6rem;
  scroll-behavior:smooth;
  background:radial-gradient(1200px 200px at 10% 0%, rgba(0,255,0,0.01), transparent 2%),transparent;
}
.msg {
  max-width:75%;
  padding:.7rem .95rem;
  border-radius:12px;
  display:inline-block;
  line-height:1.3;
  animation:enter .2s ease;
  box-shadow:0 2px 8px rgba(0,0,0,0.5);
  position:relative;
}
.msg .meta {display:block;font-size:.8rem;color:var(--muted);margin-bottom:.3rem;display:flex;align-items:center;gap:.5rem;}
.msg .meta .username {font-weight:600;}
.msg .content {margin-top:.2rem;}
.msg.me {align-self:flex-end;background:var(--accent);color:#050505;border-bottom-right-radius:4px;}
.msg.other {align-self:flex-start;background:#1a1a1a;color:#ddd;border-bottom-left-radius:4px;border:1px solid var(--border);}
.msg.system {align-self:center;background:transparent;color:#888;font-style:italic;padding:.3rem .6rem;border-radius:6px;max-width:90%;}
.admin-tag {color:var(--danger);font-weight:700;margin-left:.45rem;font-size:.75rem;}

/* Reply preview in message */
.reply-preview {
  background:rgba(0,0,0,0.3);
  padding:.4rem .6rem;
  border-left:3px solid var(--accent);
  border-radius:4px;
  margin-bottom:.4rem;
  font-size:.8rem;
  color:#aaa;
}
.reply-preview .reply-to {font-weight:600;color:var(--accent);margin-bottom:.2rem;}

/* Message actions (reply button) */
.msg-actions {
  position:absolute;
  top:.5rem;
  right:.5rem;
  display:none;
  gap:.3rem;
}
.msg:hover .msg-actions {display:flex;}
.msg-action-btn {
  background:rgba(0,0,0,0.6);
  border:1px solid rgba(255,255,255,0.1);
  color:#aaa;
  padding:.3rem .5rem;
  border-radius:4px;
  cursor:pointer;
  font-size:.75rem;
  transition:all .2s;
}
.msg-action-btn:hover {background:rgba(0,255,0,0.1);border-color:var(--accent);color:var(--accent);}

@keyframes enter { from{opacity:0;transform:translateY(6px)} to{opacity:1;transform:none} }

/* Input bar with reply indicator */
.input-bar {
  display:flex;
  flex-direction:column;
  gap:.5rem;
  padding:.9rem 1rem;
  border-top:1px solid var(--border);
  background:linear-gradient(180deg,#0f0f0f,#131313);
}
.reply-indicator {
  display:none;
  background:#2a2a2a;
  padding:.5rem .75rem;
  border-radius:8px;
  border-left:3px solid var(--accent);
  font-size:.85rem;
  color:#aaa;
  align-items:center;
  justify-content:space-between;
}
.reply-indicator.active {display:flex;}
.reply-indicator .cancel-reply {
  background:transparent;
  border:none;
  color:var(--danger);
  cursor:pointer;
  font-size:1.1rem;
  padding:.2rem;
}
.input-row {display:flex;gap:.6rem;align-items:center;}
.input-row input {
  flex:1;
  padding:14px 16px;
  border-radius:10px;
  border:2px solid var(--border);
  background:#1f1f1f;
  color:#fff;
  outline:none;
  font-size:1rem;
  font-family:'JetBrains Mono',monospace;
  transition:border-color .2s;
}
.input-row input:focus {border-color:var(--accent);box-shadow:0 0 0 3px rgba(0,255,0,0.1);}
.send-btn {
  background:var(--accent);
  border:none;
  padding:12px 18px;
  border-radius:10px;
  font-weight:700;
  cursor:pointer;
  transition:all .15s;
  color:#000;
  font-family:'JetBrains Mono',monospace;
}
.send-btn:hover {filter:brightness(1.1);transform:translateY(-1px);}
.send-btn:active {transform:scale(.98);}

/* Modals (auth, profile, settings, ban) */
.modal-overlay {
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.8);
  z-index:200;
  backdrop-filter:blur(4px);
}
.modal-overlay.active {display:flex;}
.modal-content {
  background:#1c1c1c;
  padding:2rem;
  border-radius:16px;
  border:1px solid var(--border);
  max-width:500px;
  width:92%;
  max-height:85vh;
  overflow-y:auto;
  box-shadow:0 20px 60px rgba(0,0,0,0.8);
  animation:modalEnter .3s ease;
}
/* Ensure the Call Settings modal overlays the call UI */
#callSettingsModal { z-index: 12000; }
@keyframes modalEnter { from{opacity:0;transform:scale(.95)} to{opacity:1;transform:scale(1)} }
.modal-content h2 {color:var(--accent);margin:0 0 1rem;text-align:center;font-size:1.5rem;}
.modal-content .form-group {margin-bottom:1rem;}
.modal-content .form-group label {display:block;color:#aaa;margin-bottom:.5rem;font-size:.9rem;}
.modal-content .form-group input {
  width:100%;
  padding:12px 14px;
  border-radius:8px;
  border:1px solid var(--border);
  background:#222;
  color:#fff;
  outline:none;
  font-family:'JetBrains Mono',monospace;
  transition:border-color .2s;
}
.modal-content .form-group input:focus {border-color:var(--accent);box-shadow:0 0 0 3px rgba(0,255,0,0.1);}
.modal-content .btn-group {display:flex;gap:.75rem;margin-top:1.5rem;}
.modal-content .btn {
  flex:1;
  padding:12px;
  border-radius:8px;
  border:none;
  cursor:pointer;
  font-weight:600;
  font-family:'JetBrains Mono',monospace;
  transition:all .2s;
}
.modal-content .btn-primary {background:var(--accent);color:#000;}
.modal-content .btn-primary:hover {filter:brightness(1.1);}
.modal-content .btn-secondary {background:#2a2a2a;color:#fff;border:1px solid var(--border);}
.modal-content .btn-secondary:hover {background:#333;border-color:var(--accent);color:var(--accent);}
.modal-content .error-msg {color:var(--danger);font-size:.85rem;margin-top:.5rem;display:none;}
.modal-content .info-msg {color:#aaa;font-size:.85rem;margin-top:.5rem;text-align:center;}

/* Profile modal */
.profile-modal .profile-header {
  text-align:center;
  margin-bottom:1.5rem;
  padding-bottom:1rem;
  border-bottom:1px solid var(--border);
}
.profile-modal .profile-avatar {
  width:80px;
  height:80px;
  border-radius:50%;
  background:linear-gradient(135deg,var(--accent),#00aa00);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:2rem;
  color:#000;
  font-weight:700;
  margin:0 auto 1rem;
  box-shadow:0 4px 20px rgba(0,255,0,0.3);
}
.profile-modal .profile-username {font-size:1.3rem;color:#fff;font-weight:600;margin-bottom:.3rem;}
.profile-modal .profile-status {font-size:.85rem;color:var(--muted);}
.profile-modal .profile-bio {
  background:#222;
  padding:1rem;
  border-radius:8px;
  border:1px solid var(--border);
  margin-bottom:1rem;
  color:#aaa;
  font-size:.9rem;
  line-height:1.5;
  min-height:60px;
}
.profile-modal .profile-actions {display:flex;gap:.75rem;}
.profile-modal .profile-actions .btn {flex:1;}

/* Settings modal */
.settings-modal .settings-section {margin-bottom:1.5rem;padding-bottom:1.5rem;border-bottom:1px solid var(--border);}
.settings-modal .settings-section:last-child {border-bottom:none;}
.settings-modal .settings-section h3 {color:#fff;font-size:1.1rem;margin-bottom:1rem;}
.settings-modal .setting-item {display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem;}
.settings-modal .setting-item label {color:#aaa;font-size:.9rem;}
.settings-modal .toggle-switch {
  position:relative;
  width:50px;
  height:26px;
  background:#333;
  border-radius:13px;
  cursor:pointer;
  transition:background .2s;
}
.settings-modal .toggle-switch.active {background:var(--accent);}
.settings-modal .toggle-switch::after {
  content:'';
  position:absolute;
  width:20px;
  height:20px;
  border-radius:50%;
  background:#fff;
  top:3px;
  left:3px;
  transition:left .2s;
}
.settings-modal .toggle-switch.active::after {left:27px;}

/* Ban modal */
.ban-modal {
  background:#1c1c1c;
  padding:2rem;
  border-radius:16px;
  border:2px solid var(--danger);
  max-width:450px;
  text-align:center;
  box-shadow:0 20px 60px rgba(255,102,102,0.3);
}
.ban-modal h3 {color:var(--danger);margin:0 0 1rem;font-size:1.5rem;}
.ban-modal p {color:#ddd;margin:.75rem 0 1.5rem;font-size:.95rem;line-height:1.5;}
.ban-modal .btn {
  background:#333;
  color:#fff;
  border:1px solid var(--border);
  padding:12px 24px;
  border-radius:8px;
  cursor:pointer;
  font-family:'JetBrains Mono',monospace;
  font-weight:600;
}
.ban-modal .btn:hover {background:#3a3a3a;}

/* Add custom context menu styles */
.context-menu {
  position:fixed;
  background:#1c1c1c;
  border:1px solid var(--border);
  border-radius:8px;
  padding:.5rem 0;
  min-width:180px;
  box-shadow:0 10px 30px rgba(0,0,0,0.8);
  z-index:9999;
  display:none;
}
.context-menu.active {display:block;}
.context-menu-item {
  padding:.7rem 1rem;
  color:#ddd;
  cursor:pointer;
  transition:all .15s;
  display:flex;
  align-items:center;
  gap:.6rem;
  font-size:.85rem;
}
.context-menu-item:hover {
  background:rgba(0,255,0,0.1);
  color:var(--accent);
}
.context-menu-item.danger {color:var(--danger);}
.context-menu-item.danger:hover {background:rgba(255,102,102,0.1);}

/* Add admin notification popup styles */
.admin-notification {
  position:fixed;
  top:80px;
  right:20px;
  background:#1c1c1c;
  border:2px solid var(--danger);
  border-radius:12px;
  padding:1rem 1.25rem;
  min-width:300px;
  max-width:400px;
  box-shadow:0 10px 40px rgba(255,102,102,0.4);
  z-index:9999;
  animation:slideIn .3s ease;
  display:none;
}
.admin-notification.active {display:block;}
.admin-notification .notif-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:.75rem;
}
.admin-notification .notif-title {
  color:var(--danger);
  font-weight:700;
  font-size:1rem;
  display:flex;
  align-items:center;
  gap:.5rem;
}
.admin-notification .notif-close {
  background:transparent;
  border:none;
  color:#888;
  cursor:pointer;
  font-size:1.3rem;
  padding:0;
  transition:color .2s;
}
.admin-notification .notif-close:hover {color:var(--danger);}
.admin-notification .notif-body {
  color:#ddd;
  font-size:.85rem;
  line-height:1.4;
}
.admin-notification .notif-meta {
  color:#888;
  font-size:.75rem;
  margin-top:.5rem;
  padding-top:.5rem;
  border-top:1px solid var(--border);
}
@keyframes slideIn {
  from {transform:translateX(400px);opacity:0;}
  to {transform:translateX(0);opacity:1;}
}

/* Add chat shutdown modal styles */
.shutdown-modal {
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.9);
  z-index:9999;
  backdrop-filter:blur(8px);
}
.shutdown-modal.active {display:flex;}
.shutdown-content {
  background:#1c1c1c;
  padding:2.5rem;
  border-radius:16px;
  border:2px solid var(--danger);
  max-width:500px;
  width:92%;
  text-align:center;
  box-shadow:0 20px 60px rgba(255,102,102,0.4);
  animation:modalEnter .3s ease;
}
.shutdown-icon {
  font-size:4rem;
  color:var(--danger);
  margin-bottom:1rem;
}
.shutdown-content h2 {
  color:var(--danger);
  font-size:1.8rem;
  margin-bottom:1rem;
}
.shutdown-content p {
  color:#aaa;
  font-size:1rem;
  line-height:1.6;
  margin-bottom:1.5rem;
}

/* Responsive */
@media (max-width:900px){
  .layout {flex-direction:column;}
  .users-panel {
    order:2;
    height:140px;
    display:flex;
    flex-direction:row;
    gap:.5rem;
    overflow-x:auto;
    width:100%;
    border-right:none;
    border-top:1px solid var(--border);
  }
  .users-panel .user-row {min-width:140px;flex-direction:column;align-items:flex-start;}
  .chat-card {height:calc(100vh - 210px);}
  .room-tabs {padding:.5rem .75rem;}
  .room-tab {padding:.4rem .8rem;font-size:.8rem;}
}

/* Call UI */
.call-overlay {
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.8);
  z-index:400;
  backdrop-filter:blur(6px);
}
.call-overlay.active {display:flex;}
.call-card {
  width:92%;
  max-width:460px;
  background:#1b1b1b;
  border:1px solid var(--border);
  border-radius:16px;
  padding:1.25rem 1.25rem 1rem;
  box-shadow:0 20px 60px rgba(0,0,0,0.8);
  text-align:center;
}
.call-avatar {
  width:96px;height:96px;border-radius:50%;
  margin:0 auto .9rem;
  display:flex;align-items:center;justify-content:center;
  background:linear-gradient(135deg,var(--accent),#0a0);
  color:#000;font-weight:800;font-size:2rem;
}
.call-name {color:#fff;font-weight:700;margin-bottom:.25rem;}
.call-status {color:var(--muted);font-size:.9rem;margin-bottom:1rem;}
.call-controls {display:flex;gap:.6rem;justify-content:center;}
.call-controls .btn {
  min-width:46px;min-height:42px;padding:.6rem .9rem;border-radius:10px;border:1px solid var(--border);
  background:#2a2a2a;color:#ddd;cursor:pointer;transition:all .2s;display:flex;align-items:center;gap:.4rem;
}
.call-controls .btn:hover {background:#333;border-color:var(--accent);color:var(--accent);}
.btn-danger {background:#3a1f1f;border-color:#552222;color:#ff9a9a;}
.btn-danger:hover {background:#4a2323;border-color:#ff6666;color:#ff6666;}

/* Minimized call widget */
.call-widget {
  position:fixed;
  background:#1c1c1c;border:1px solid var(--border);border-radius:12px;
  padding:.6rem .75rem;min-width:220px;display:none;align-items:center;justify-content:space-between;z-index:410;
  box-shadow:0 10px 30px rgba(0,0,0,0.6);
  transition: top .2s ease, left .2s ease, right .2s ease, bottom .2s ease;
  cursor:grab;
  top:auto;left:auto;right:auto;bottom:auto;
}
.call-widget.active {display:flex;}
.call-widget .title {color:#fff;font-weight:600;font-size:.9rem;}
.call-widget .meta {color:#888;font-size:.8rem;}
.call-widget .actions {display:flex;gap:.35rem;}
.hidden {display:none !important;}

/* Call devices row */
.call-devices {margin-top:.9rem; display:flex; gap:.5rem; justify-content:center; align-items:center; flex-wrap:wrap; color:#aaa; font-size:.85rem;}
.call-devices label {opacity:.8; margin:0 .15rem;}
.call-devices select {background:#2a2a2a; border:1px solid var(--border); color:#ddd; border-radius:8px; padding:.35rem .6rem; font-family:'JetBrains Mono', monospace;}
/* Video stage */
.video-stage { position:relative; width:100%; margin:.75rem auto 0; max-width:900px; aspect-ratio:16/9; background:#0e0e0e; border:1px solid var(--border); border-radius:10px; overflow:hidden; }
.video-stage video { width:100%; height:100%; object-fit:cover; background:#000; }
.video-stage .local-preview { position:absolute; width:26%; aspect-ratio:16/9; right:10px; bottom:10px; border:1px solid var(--border); border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,0.5); }
.video-settings { margin-top:.6rem; display:flex; gap:.5rem; justify-content:center; align-items:center; flex-wrap:wrap; color:#aaa; font-size:.85rem; }
.video-settings label {opacity:.8; margin:0 .15rem;}
.video-settings select, .video-settings input {background:#2a2a2a; border:1px solid var(--border); color:#ddd; border-radius:8px; padding:.35rem .6rem; font-family:'JetBrains Mono', monospace;}
  </style>
</head>
<body>
  <!-- Enhanced navbar with settings -->
  <nav class="navbar">
    <div class="logo-nav">
      <img src="../logo.png" alt="logo">
      <span>polar's.shack</span>
    </div>
    <div class="nav-links">
      <a href="index.html">home</a>
      <a href="chat.html" class="active">chat</a>
      <button id="settingsBtn" class="nav-btn"><i class='bx bx-cog'></i> settings</button>
      <button id="logoutBtn" class="nav-btn"><i class='bx bx-log-out'></i> logout</button>
    </div>
  </nav>

  <div class="layout">
    <!-- Users panel with click to view profile -->
    <aside class="users-panel">
      <h3>online users</h3>
      <div id="usersList"></div>
    </aside>

    <section class="chat-card">
      <!-- Room tabs for public + DMs -->
      <div class="room-tabs" id="roomTabs">
        <div class="room-tab active" data-room="public">
          <i class='bx bx-globe'></i> public chat
        </div>
      </div>

      <div class="chat-header">
        <div class="title" id="chatTitle">public chat</div>
        <div class="right">
          <span id="meDisplay">@guest</span>
          <button id="startCallBtn" class="icon-btn hidden" title="Start call"><i class='bx bx-phone'></i></button>
        </div>
      </div>

      <div id="messages" class="messages"></div>

      <!-- Input bar with reply indicator -->
      <div class="input-bar">
        <div class="reply-indicator" id="replyIndicator">
          <span id="replyText">replying to...</span>
          <button class="cancel-reply" id="cancelReply"><i class='bx bx-x'></i></button>
        </div>
        <div class="input-row">
          <input id="messageInput" placeholder="Say something — press Enter to send" autocomplete="off" />
          <button class="send-btn" id="sendBtn">send</button>
        </div>
       <div id="sendHint" style="font-size:.8rem;color:#888;margin-top:.25rem;"></div>
      </div>
    </section>
  </div>

  <!-- Auth modal with email verification -->
  <div id="authModal" class="modal-overlay active">
    <div class="modal-content">
      <h2>sign in / sign up</h2>
      <div id="signInForm">
        <div class="form-group">
          <label for="signInUsername">username</label>
          <input id="signInUsername" placeholder="your username" />
        </div>
        <div class="form-group">
          <label for="signInPassword">password</label>
          <input id="signInPassword" type="password" placeholder="your password" />
        </div>
        <div class="btn-group">
          <button id="signInBtn" class="btn btn-primary">sign in</button>
          <button id="showSignUpBtn" class="btn btn-secondary">need an account?</button>
        </div>
        <p id="signInError" class="error-msg"></p>
      </div>

      <div id="signUpForm" style="display:none;">
        <div class="form-group">
          <label for="authEmail">email</label>
          <input id="authEmail" type="email" placeholder="your@email.com" />
        </div>
        <div class="form-group">
          <label for="authUsername">username</label>
          <input id="authUsername" placeholder="choose a unique username" />
        </div>
        <div class="form-group">
          <label for="authPassword">password</label>
          <input id="authPassword" type="password" placeholder="secure password" />
        </div>
        <div class="btn-group">
          <button id="signUpBtn" class="btn btn-primary">sign up</button>
          <button id="showSignInBtn" class="btn btn-secondary">have an account?</button>
        </div>
        <p class="info-msg">email verification required for new accounts</p>
        <p id="authError" class="error-msg"></p>
      </div>
    </div>
  </div>

  <!-- Profile modal -->
  <div id="profileModal" class="modal-overlay">
    <div class="modal-content profile-modal">
      <div class="profile-header">
        <div class="profile-avatar" id="profileAvatar">U</div>
        <div class="profile-username" id="profileUsername">username</div>
        <div class="profile-status" id="profileStatus">online</div>
      </div>
      <div class="profile-bio" id="profileBio">no bio set</div>
      <div class="profile-actions">
        <button class="btn btn-primary" id="dmUserBtn"><i class='bx bx-message'></i> send DM</button>
        <button class="btn btn-secondary" id="closeProfileBtn">close</button>
      </div>
    </div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal" class="modal-overlay">
    <div class="modal-content settings-modal">
      <h2>settings</h2>
      
      <div class="settings-section">
        <h3>account</h3>
        <div class="form-group">
          <label for="newUsername">change username</label>
          <input id="newUsername" placeholder="new username" />
        </div>
        <button class="btn btn-primary" id="updateUsernameBtn">update username</button>
      </div>

      <div class="settings-section">
        <h3>profile</h3>
        <div class="form-group">
          <label for="userBio">bio</label>
          <input id="userBio" placeholder="tell others about yourself" maxlength="150" />
        </div>
        <button class="btn btn-primary" id="updateBioBtn">update bio</button>
      </div>

      <div class="settings-section">
        <h3>notifications</h3>
        <div class="setting-item">
          <label>sound notifications</label>
          <div class="toggle-switch" id="soundToggle"></div>
        </div>
        <div class="setting-item">
          <label>desktop notifications</label>
          <div class="toggle-switch" id="desktopToggle"></div>
        </div>
      </div>

      <div class="settings-section">
        <h3>privacy</h3>
        <div class="setting-item">
          <label>show online status</label>
          <div class="toggle-switch active" id="onlineToggle"></div>
        </div>
      </div>

      <button class="btn btn-secondary" id="closeSettingsBtn">close</button>
      <p id="settingsError" class="error-msg"></p>
    </div>
  </div>

  <!-- Ban modal -->
  <div id="banModal" class="modal-overlay">
    <div class="ban-modal">
      <h3>account banned</h3>
      <p id="banReason">you have been banned from chat.</p>
      <button class="btn" id="closeBanBtn">ok</button>
    </div>
  </div>

  <!-- Add custom context menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" id="ctxReply">
      <i class='bx bx-reply'></i> reply to message
    </div>
    <div class="context-menu-item" id="ctxCopy">
      <i class='bx bx-copy'></i> copy text
    </div>
    <div class="context-menu-item danger" id="ctxReport">
      <i class='bx bx-flag'></i> report message
    </div>
  </div>

  <!-- Add admin notification popup -->
  <div class="admin-notification" id="adminNotification">
    <div class="notif-header">
      <div class="notif-title">
        <i class='bx bx-error-circle'></i> message reported
      </div>
      <button class="notif-close" onclick="closeAdminNotif()"><i class='bx bx-x'></i></button>
    </div>
    <div class="notif-body" id="notifBody"></div>
    <div class="notif-meta" id="notifMeta"></div>
  </div>

  <!-- Add chat shutdown modal -->
  <div class="shutdown-modal" id="shutdownModal">
    <div class="shutdown-content">
      <div class="shutdown-icon"><i class='bx bx-error-circle'></i></div>
      <h2>chat shutdown</h2>
      <p>the chat has been temporarily shut down by an administrator. please check back later.</p>
    </div>
  </div>

  <!-- Call overlay -->
  <div class="call-overlay" id="callOverlay">
    <div class="call-card">
      <div class="call-avatar" id="callAvatar">U</div>
      <div class="call-name" id="callName">username</div>
      <div class="call-status" id="callStatus">calling…</div>
      <div class="video-stage hidden" id="videoStage">
        <video id="remoteVideo" autoplay playsinline></video>
        <video id="localVideo" class="local-preview" autoplay playsinline muted></video>
      </div>
      <div class="call-controls">
        <button class="btn" id="toggleMicBtn"><i class='bx bx-microphone'></i><span class="lbl">mic</span></button>
        <button class="btn" id="toggleVideoBtn" title="Toggle camera"><i class='bx bx-video'></i><span class="lbl">video</span></button>
        <button class="btn" id="shareScreenBtn" title="Share your screen"><i class='bx bx-desktop'></i><span class="lbl">share</span></button>
        <button class="btn" id="callSettingsBtn" title="Call settings"><i class='bx bx-slider-alt'></i><span class="lbl">settings</span></button>
        <button class="btn" id="minimizeCallBtn"><i class='bx bx-message'></i><span class="lbl">chat</span></button>
        <button class="btn btn-danger" id="hangupBtn"><i class='bx bx-phone-off'></i><span class="lbl">hang up</span></button>
      </div>
    </div>
  </div>

  <!-- Minimized call widget -->
  <div class="call-widget" id="callWidget">
    <div>
      <div class="title" id="widgetName">username</div>
      <div class="meta" id="widgetTimer">00:00</div>
    </div>
    <div class="actions">
      <button class="icon-btn" id="restoreCallBtn" title="Back to call"><i class='bx bx-expand-alt'></i></button>
      <button class="icon-btn" id="widgetHangupBtn" title="Hang up"><i class='bx bx-phone-off'></i></button>
    </div>
  </div>

  <!-- Remote audio output (hidden) -->
  <audio id="remoteAudio" autoplay playsinline class="hidden"></audio>

  <!-- Incoming call modal -->
  <div class="modal-overlay" id="incomingCallModal">
    <div class="modal-content" style="max-width:420px;text-align:center;">
      <h2>incoming call</h2>
      <div class="profile-avatar" id="incomingAvatar">U</div>
      <div class="profile-username" id="incomingName">user</div>
      <p class="info-msg">someone is calling you. answer?</p>
      <div class="btn-group">
        <button id="acceptCallBtn" class="btn btn-primary"><i class='bx bx-phone'></i> accept</button>
        <button id="declineCallBtn" class="btn btn-secondary"><i class='bx bx-phone-off'></i> decline</button>
      </div>
    </div>
  </div>

  <!-- Call Settings modal -->
  <div class="modal-overlay" id="callSettingsModal">
    <div class="modal-content" style="max-width:640px;">
      <h2>call settings</h2>

      <div class="settings-section">
        <h3>audio input</h3>
        <div class="form-group">
          <label for="micSelect">microphone</label>
          <select id="micSelect"></select>
        </div>
      </div>

      <div class="settings-section">
        <h3>audio output</h3>
        <div class="form-group">
          <label for="spkSelect">speaker/output</label>
          <select id="spkSelect"></select>
        </div>
      </div>

      <div class="settings-section">
        <h3>camera</h3>
        <div class="form-group">
          <label for="camSelect">camera device</label>
          <select id="camSelect"></select>
        </div>
      </div>

      <div class="settings-section">
        <h3>video quality</h3>
        <div class="form-group">
          <label for="videoResSelect">resolution</label>
          <select id="videoResSelect">
            <option value="1080">1080p</option>
            <option value="720">720p</option>
          </select>
        </div>
        <div class="form-group">
          <label for="videoFpsSelect">frame rate</label>
          <select id="videoFpsSelect">
            <option value="60">60</option>
            <option value="30">30</option>
          </select>
        </div>
        <div class="form-group">
          <label for="videoBitrate">bitrate (kbps)</label>
          <input id="videoBitrate" type="number" min="300" max="12000" step="100" />
        </div>
      </div>

      <div class="settings-section">
        <h3>screen share</h3>
        <div class="form-group">
          <label for="screenResSelect">resolution</label>
          <select id="screenResSelect">
            <option value="1080">1080p</option>
            <option value="720">720p</option>
          </select>
        </div>
        <div class="form-group">
          <label for="screenFpsSelect">frame rate</label>
          <select id="screenFpsSelect">
            <option value="60">60</option>
            <option value="30">30</option>
          </select>
        </div>
      </div>

      <button class="btn btn-secondary" id="closeCallSettingsBtn">close</button>
    </div>
  </div>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBYyJuTAkVPB_65NqSeca6IueMoMO1iPzs",
      authDomain: "polars-shack.firebaseapp.com",
      projectId: "polars-shack",
      storageBucket: "polars-shack.firebasestorage.app",
      messagingSenderId: "205388124682",
      appId: "1:205388124682:web:2b0b1605517e0c6c53c5f3"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const rtdb = firebase.database();
  // keep users signed in across sessions
  auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(()=>{});

    const offensiveWords = ['badword1', 'badword2', 'offensive', 'inappropriate'];
    function containsOffensive(text) {
      const lower = text.toLowerCase();
      return offensiveWords.some(word => lower.includes(word));
    }

    const settings = {
  chatShutdown: false,
  lockdown: false,
  slowMode: 0,               // seconds
  lastSentAt: 0,             // per-session cache
};

    // paste your block RIGHT HERE:
function renderSendHint(){
  const el = document.getElementById('sendHint');
  if (!el) return;
  if (settings.chatShutdown) el.textContent = 'Chat is shut down by an admin.';
  else if (settings.lockdown) el.textContent = 'Lockdown is active. Only admins can send messages.';
  else if (settings.slowMode > 0) el.textContent = `Slow mode: ${settings.slowMode}s`;
  else el.textContent = '';
}
['chatShutdown','lockdown','slowMode'].forEach(k=>{
  Object.defineProperty(settings, k, {
    set(v){ this['_' + k] = v; renderSendHint(); },
    get(){ return this['_' + k]; }
  });
});
renderSendHint();

function nowMs(){ return Date.now(); }
function secondsLeft(endMs){ return Math.max(0, Math.ceil((endMs - nowMs())/1000)); }

    let lastMessage = '';
    let lastMessageTime = 0;

    let replyingTo = null;

    let contextMenuTarget = null;

    let currentUser = null;
    let currentRoom = 'public';
    let unsubscribeMessages = null;
    let dmRooms = [];
    let unreadDMs = {};

// add these two listeners
rtdb.ref('settings/lockdown').on('value', s => {
  settings.lockdown = !!s.val();
});

rtdb.ref('settings/slowMode').on('value', s => {
  const v = s.val();
  settings.slowMode = typeof v === 'number' && v > 0 ? v : 0;
});

    document.getElementById('signUpBtn').addEventListener('click', signUp);
    document.getElementById('signInBtn').addEventListener('click', signIn);
    document.getElementById('logoutBtn').addEventListener('click', logout);
    document.getElementById('settingsBtn').addEventListener('click', () => {
      if (currentUser) {
        document.getElementById('newUsername').value = currentUser.username;
        document.getElementById('userBio').value = currentUser.bio || '';
      }
      document.getElementById('settingsModal').classList.add('active');
    });
    document.getElementById('closeSettingsBtn').addEventListener('click', () => {
      document.getElementById('settingsModal').classList.remove('active');
    });
    document.getElementById('closeProfileBtn').addEventListener('click', () => {
      document.getElementById('profileModal').classList.remove('active');
    });
    document.getElementById('closeBanBtn').addEventListener('click', () => {
      document.getElementById('banModal').classList.remove('active');
    });

    document.getElementById('updateUsernameBtn').addEventListener('click', async () => {
      const newUsername = document.getElementById('newUsername').value.trim();
      
      if (!newUsername) {
        document.getElementById('settingsError').textContent = 'Username cannot be empty';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      if (containsOffensive(newUsername)) {
        document.getElementById('settingsError').textContent = 'Username contains inappropriate content';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      // Check if username is already taken
      const usernameQuery = await db.collection('users').where('username', '==', newUsername).get();
      if (!usernameQuery.empty && usernameQuery.docs[0].id !== currentUser.uid) {
        document.getElementById('settingsError').textContent = 'Username already taken';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      try {
        await db.collection('users').doc(currentUser.uid).update({ username: newUsername });
        currentUser.username = newUsername;
        document.getElementById('meDisplay').textContent = `@${newUsername}`;
        document.getElementById('settingsError').textContent = 'Username updated successfully!';
        document.getElementById('settingsError').style.color = '#00ff00';
        document.getElementById('settingsError').style.display = 'block';
        setTimeout(() => {
          document.getElementById('settingsError').style.display = 'none';
          document.getElementById('settingsError').style.color = '#ff6666';
        }, 3000);
      } catch (error) {
        document.getElementById('settingsError').textContent = 'Failed to update username';
        document.getElementById('settingsError').style.display = 'block';
      }
    });

    document.getElementById('updateBioBtn').addEventListener('click', async () => {
      const newBio = document.getElementById('userBio').value.trim();

      if (containsOffensive(newBio)) {
        document.getElementById('settingsError').textContent = 'Bio contains inappropriate content';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      try {
        await db.collection('users').doc(currentUser.uid).update({ bio: newBio });
        currentUser.bio = newBio;
        document.getElementById('settingsError').textContent = 'Bio updated successfully!';
        document.getElementById('settingsError').style.color = '#00ff00';
        document.getElementById('settingsError').style.display = 'block';
        setTimeout(() => {
          document.getElementById('settingsError').style.display = 'none';
          document.getElementById('settingsError').style.color = '#ff6666';
        }, 3000);
      } catch (error) {
        document.getElementById('settingsError').textContent = 'Failed to update bio';
        document.getElementById('settingsError').style.display = 'block';
      }
    });

    document.getElementById('soundToggle').addEventListener('click', function() {
      this.classList.toggle('active');
      const enabled = this.classList.contains('active');
      localStorage.setItem('soundNotifications', enabled);
    });

    document.getElementById('desktopToggle').addEventListener('click', function() {
      this.classList.toggle('active');
      const enabled = this.classList.contains('active');
      localStorage.setItem('desktopNotifications', enabled);
      if (enabled && 'Notification' in window) {
        Notification.requestPermission();
      }
    });

    document.getElementById('onlineToggle').addEventListener('click', async function() {
      this.classList.toggle('active');
      const enabled = this.classList.contains('active');
      if (currentUser) {
        await db.collection('users').doc(currentUser.uid).update({ showOnlineStatus: enabled });
      }
    });

    document.getElementById('dmUserBtn').addEventListener('click', async () => {
      const profileUsername = document.getElementById('profileUsername').textContent;
      
      // Find the user by username
      const userQuery = await db.collection('users').where('username', '==', profileUsername).get();
      if (userQuery.empty) return;
      
      const targetUser = { uid: userQuery.docs[0].id, ...userQuery.docs[0].data() };
      
      // Create DM room ID (sorted UIDs to ensure consistency)
      const roomId = [currentUser.uid, targetUser.uid].sort().join('_');
      
      // Check if DM room already exists
      if (!dmRooms.find(room => room.id === roomId)) {
        dmRooms.push({
          id: roomId,
          name: `@${targetUser.username}`,
          type: 'dm',
          participants: [currentUser.uid, targetUser.uid]
        });
        
        // Save DM room to user's account
        await db.collection('users').doc(currentUser.uid).update({
          dmRooms: firebase.firestore.FieldValue.arrayUnion({
            roomId,
            withUser: targetUser.uid,
            withUsername: targetUser.username
          })
        });
        
        renderRoomTabs();
        // dm list changed, refresh watchers without losing last ids
        initDmNotificationWatchers();
        initGlobalCallWatchers();
      }
      
      // Switch to DM room
      switchRoom(roomId);
      document.getElementById('profileModal').classList.remove('active');
    });

    document.getElementById('cancelReply').addEventListener('click', () => {
      replyingTo = null;
      document.getElementById('replyIndicator').classList.remove('active');
    });

    const contextMenu = document.getElementById('contextMenu');
    document.addEventListener('contextmenu', (e) => {
      const msgEl = e.target.closest('.msg');
      if (msgEl && !msgEl.classList.contains('system')) {
        e.preventDefault();
        contextMenuTarget = msgEl;
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
        contextMenu.classList.add('active');
      }
    });

    document.addEventListener('click', () => {
      contextMenu.classList.remove('active');
    });

    document.getElementById('ctxReply').addEventListener('click', () => {
      if (contextMenuTarget) {
        const username = contextMenuTarget.querySelector('.username').textContent;
        const content = contextMenuTarget.querySelector('.content').textContent;
        replyingTo = { username, content };
        document.getElementById('replyText').textContent = `replying to ${username}`;
        document.getElementById('replyIndicator').classList.add('active');
        document.getElementById('messageInput').focus();
      }
    });

    document.getElementById('ctxCopy').addEventListener('click', () => {
      if (contextMenuTarget) {
        const content = contextMenuTarget.querySelector('.content').textContent;
        navigator.clipboard.writeText(content);
      }
    });

    document.getElementById('ctxReport').addEventListener('click', () => {
      if (contextMenuTarget) {
        const username = contextMenuTarget.querySelector('.username').textContent;
        const content = contextMenuTarget.querySelector('.content').textContent;
        const timestamp = contextMenuTarget.querySelector('.meta span:last-child').textContent;
        reportMessage(username, content, timestamp);
      }
    });

    async function reportMessage(username, content, timestamp) {
      const reportData = {
        reporter: currentUser.username,
        reporterUid: currentUser.uid,
        reportedUser: username,
        message: content,
        messageTime: timestamp,
        room: currentRoom,
        timestamp: Date.now(),
        status: 'pending'
      };

      try {
        // Save report to database
        await db.collection('reports').add(reportData);
        
        // Show confirmation to reporter
        alert('Message reported successfully. Admins will review it shortly.');
        
        // Notify all online admins in real-time
        const adminsSnapshot = await db.collection('users').where('isAdmin', '==', true).where('online', '==', true).get();
        
        adminsSnapshot.forEach(async (doc) => {
          const adminData = doc.data();
          // Create notification for admin
          await db.collection('notifications').add({
            recipientUid: doc.id,
            type: 'report',
            title: 'New Message Report',
            body: `User "${username}" reported by ${currentUser.username}`,
            message: content,
            timestamp: Date.now(),
            read: false
          });
        });
        
        // Show notification to admins who are currently online
        notifyOnlineAdmins(username, content, timestamp);
      } catch (error) {
        console.error('[v0] Report error:', error);
        alert('Failed to submit report. Please try again.');
      }
    }

    function notifyOnlineAdmins(reportedUser, message, timestamp) {
      // Listen for admin notifications if current user is admin
      if (currentUser && currentUser.isAdmin) {
        const notif = document.getElementById('adminNotification');
        document.getElementById('notifBody').innerHTML = `
          <strong>Reported User:</strong> ${reportedUser}<br>
          <strong>Message:</strong> "${message}"<br>
          <strong>Time:</strong> ${timestamp}
        `;
        document.getElementById('notifMeta').textContent = `Reported by: ${currentUser.username} at ${new Date().toLocaleTimeString()}`;
        notif.classList.add('active');
        
        // Auto-hide after 15 seconds
        setTimeout(() => notif.classList.remove('active'), 15000);
      }
    }

    function closeAdminNotif() {
      document.getElementById('adminNotification').classList.remove('active');
    }

    rtdb.ref('settings/chatShutdown').on('value', (snapshot) => {
      const isShutdown = snapshot.val();
      if (isShutdown) {
        document.getElementById('shutdownModal').classList.add('active');
      } else {
        document.getElementById('shutdownModal').classList.remove('active');
      }
    });

    async function signUp() {
      const email = document.getElementById('authEmail').value;
      const username = document.getElementById('authUsername').value;
      const password = document.getElementById('authPassword').value;

      if (containsOffensive(username)) {
        document.getElementById('authError').textContent = 'Username contains inappropriate content';
        document.getElementById('authError').style.display = 'block';
        return;
      }

      try {
        const userCred = await auth.createUserWithEmailAndPassword(email, password);
        await db.collection('users').doc(userCred.user.uid).set({
          username,
          email,
          createdAt: Date.now(),
          isAdmin: false,
          isBanned: false,
          online: true,
          bio: '',
          dmRooms: [],
          showOnlineStatus: true
        });
        document.getElementById('authModal').classList.remove('active');
      } catch (error) {
        document.getElementById('authError').textContent = error.message;
        document.getElementById('authError').style.display = 'block';
      }
    }

    async function signIn() {
      const username = document.getElementById('signInUsername').value.trim();
      const password = document.getElementById('signInPassword').value;

      if (!username || !password) {
        document.getElementById('signInError').textContent = 'Please enter username and password';
        document.getElementById('signInError').style.display = 'block';
        return;
      }

      try {
        // Find user by username
        const userQuery = await db.collection('users').where('username', '==', username).limit(1).get();
        
        if (userQuery.empty) {
          document.getElementById('signInError').textContent = 'Username not found';
          document.getElementById('signInError').style.display = 'block';
          return;
        }

        const userDoc = userQuery.docs[0];
        const userData = userDoc.data();
        
        // Sign in with email and password
        await auth.signInWithEmailAndPassword(userData.email, password);
        document.getElementById('authModal').classList.remove('active');
        document.getElementById('signInError').style.display = 'none';
      } catch (error) {
        console.error('[v0] Sign in error:', error);
        document.getElementById('signInError').textContent = 'Invalid username or password';
        document.getElementById('signInError').style.display = 'block';
      }
    }

    function logout() {
      auth.signOut();
    }

    auth.onAuthStateChanged(async (user) => {
      console.log('[v0] Auth state changed:', user ? user.uid : 'no user');
      if (user) {
        const userDoc = await db.collection('users').doc(user.uid).get();
        if (userDoc.exists) {
          currentUser = { uid: user.uid, ...userDoc.data() };
          console.log('[v0] Current user loaded:', currentUser);
          
          if (currentUser.isBanned) {
            document.getElementById('banModal').classList.add('active');
            document.getElementById('banReason').textContent = currentUser.banReason || 'You have been banned from chat.';
            auth.signOut();
            return;
          }

          document.getElementById('meDisplay').textContent = `@${currentUser.username}`;
          await db.collection('users').doc(user.uid).update({ online: true });
          
          if (currentUser.dmRooms && currentUser.dmRooms.length > 0) {
            dmRooms = currentUser.dmRooms.map(dm => ({
              id: dm.roomId,
              name: `@${dm.withUsername}`,
              type: 'dm',
              participants: [currentUser.uid, dm.withUser]
            }));
            renderRoomTabs();
            // start global watchers when DMs available
            initDmNotificationWatchers();
            initGlobalCallWatchers();
          }
          
          loadMessages();
          loadOnlineUsers();
          
          // Load saved settings
          const soundEnabled = localStorage.getItem('soundNotifications') !== 'false';
          const desktopEnabled = localStorage.getItem('desktopNotifications') === 'true';
          if (soundEnabled) document.getElementById('soundToggle').classList.add('active');
          if (desktopEnabled) document.getElementById('desktopToggle').classList.add('active');
          if (currentUser.showOnlineStatus !== false) document.getElementById('onlineToggle').classList.add('active');
          
          console.log('[v0] Messages and users loaded');
        } else {
          console.error('[v0] User document does not exist');
        }
      } else {
        currentUser = null;
        document.getElementById('authModal').classList.add('active');
        document.getElementById('meDisplay').textContent = '@guest';
        cleanupDmNotificationWatchers();
        cleanupGlobalCallWatchers();
      }
    });

    function switchRoom(roomId) {
      currentRoom = roomId;
      loadMessages();
      
      if (unreadDMs[roomId]) {
        delete unreadDMs[roomId];
        renderRoomTabs();
      }
      
      // Update active tab
      document.querySelectorAll('.room-tab').forEach(tab => {
        tab.classList.remove('active');
        if (tab.dataset.room === roomId) {
          tab.classList.add('active');
        }
      });
      
      // Update chat title
      const room = dmRooms.find(r => r.id === roomId);
      if (room) {
        document.getElementById('chatTitle').textContent = `DM with ${room.name}`;
        // show call button in DMs
        document.getElementById('startCallBtn').classList.remove('hidden');
        // update call target name/avatar
        const targetName = room.name.replace(/^@/, '');
        document.getElementById('callName').textContent = targetName;
        document.getElementById('widgetName').textContent = targetName;
        document.getElementById('callAvatar').textContent = targetName[0]?.toUpperCase() || 'U';
        initCallWatcherForRoom();
      } else {
        document.getElementById('chatTitle').textContent = 'public chat';
        document.getElementById('startCallBtn').classList.add('hidden');
      }
    }

    function renderRoomTabs() {
      const tabsContainer = document.getElementById('roomTabs');
      tabsContainer.innerHTML = `
        <div class="room-tab ${currentRoom === 'public' ? 'active' : ''}" data-room="public">
          <i class='bx bx-globe'></i> public chat
        </div>
      `;
      
      dmRooms.forEach(room => {
        const tab = document.createElement('div');
        tab.className = `room-tab ${currentRoom === room.id ? 'active' : ''}`;
        tab.dataset.room = room.id;
        
        const hasUnread = unreadDMs[room.id];
        const notifDot = hasUnread ? '<span style="width:8px;height:8px;background:#ff6666;border-radius:50%;display:inline-block;margin-left:4px;box-shadow:0 0 8px #ff6666;"></span>' : '';
        
        tab.innerHTML = `
          <i class='bx bx-message'></i> ${room.name}${notifDot}
          <span class="close-dm" data-room="${room.id}">×</span>
        `;
        tab.addEventListener('click', (e) => {
          if (!e.target.classList.contains('close-dm')) {
            switchRoom(room.id);
          }
        });
        
        // Close DM functionality
        tab.querySelector('.close-dm').addEventListener('click', async (e) => {
          e.stopPropagation();
          dmRooms = dmRooms.filter(r => r.id !== room.id);
          await db.collection('users').doc(currentUser.uid).update({
            dmRooms: dmRooms.map(r => ({
              roomId: r.id,
              withUser: r.participants.find(uid => uid !== currentUser.uid),
              withUsername: r.name.substring(1)
            }))
          });
          if (currentRoom === room.id) {
            switchRoom('public');
          }
          renderRoomTabs();
          // dm list changed, refresh watchers without losing last ids
          initDmNotificationWatchers();
          initGlobalCallWatchers();
        });
        
        tabsContainer.appendChild(tab);
      });
      
      // Add click handlers to public tab
      tabsContainer.querySelector('[data-room="public"]').addEventListener('click', () => {
        switchRoom('public');
      });
    }

// ===== Infinite scroll + realtime (25/page, cap 100) =====
const PAGE_SIZE = 25;
const MAX_CACHE = 100;

let messagesCache = [];           // ASC (oldest -> newest)
let knownIds = new Set();         // for dedupe across sources
let unsubscribeLatest = null;     // realtime unsub for newest tail
let olderCursorDesc = null;       // desc cursor to fetch older pages
let latestCursorAsc = null;       // asc cursor to fetch truly-new messages
let hasMoreOlder = true;
let isLoadingOlder = false;

let autoScroll = true;            // if true, stick to bottom as new msgs come in
let nearTopPx = 60;
let nearBottomPx = 80;

// safe DOM text setter (prevents XSS)
function setText(el, text) { el.textContent = (text ?? '').toString(); }

function isNearBottom(box){
  return (box.scrollHeight - box.scrollTop - box.clientHeight) <= nearBottomPx;
}
function isNearTop(box){
  return box.scrollTop <= nearTopPx;
}

// render all cached messages (ASC). If keepPos is true, preserve scroll position (used when prepending older).
function renderMessages({ keepPos = false } = {}) {
  const box = document.getElementById('messages');
  let prevH = 0;
  if (keepPos) prevH = box.scrollHeight;

  const frag = document.createDocumentFragment();
  // OPTIONAL: faster incremental render — clear and rebuild since cap ≤ 100
  box.innerHTML = '';

  for (const msg of messagesCache) {
    const ts = msg.timestamp && typeof msg.timestamp.toMillis === 'function'
      ? msg.timestamp.toMillis()
      : (typeof msg.timestamp === 'number' ? msg.timestamp : Date.now());

    const mine = currentUser && msg.uid === currentUser.uid;
    const cls = msg.type === 'system' ? 'system' : (mine ? 'me' : 'other');

    const outer = document.createElement('div');
    outer.className = `msg ${cls}`;

    if (msg.type === 'system') {
      const c = document.createElement('div');
      c.className = 'content';
      setText(c, msg.text || '');
      outer.appendChild(c);
    } else {
      const meta = document.createElement('div');
      meta.className = 'meta';

      const name = document.createElement('span');
      name.className = 'username';
      setText(name, msg.username || 'unknown');
      meta.appendChild(name);

      if (msg.isAdmin) {
        const tag = document.createElement('span');
        tag.className = 'admin-tag';
        tag.textContent = 'ADMIN';
        meta.appendChild(tag);
      }

      const time = document.createElement('span');
      time.textContent = new Date(ts).toLocaleTimeString();
      meta.appendChild(time);
      outer.appendChild(meta);

      if (msg.replyTo) {
        const rp = document.createElement('div');
        rp.className = 'reply-preview';
        const to = document.createElement('div');
        to.className = 'reply-to';
        setText(to, '@' + (msg.replyTo.username || ''));
        rp.appendChild(to);
        const rc = document.createElement('div');
        setText(rc, (msg.replyTo.content || ''));
        rp.appendChild(rc);
        outer.appendChild(rp);
      }

      const content = document.createElement('div');
      content.className = 'content';
      setText(content, msg.text || '');
      outer.appendChild(content);

      // DM “Seen” tag on my last message (filled by DM extras hook)
      if (currentRoom !== 'public' && mine) {
        const seen = document.createElement('div');
        seen.className = 'meta';
        seen.style.fontSize = '.7rem';
        seen.dataset.seenFor = msg.id; // used by DM extras updater
        outer.appendChild(seen);
      }
    }

    frag.appendChild(outer);
  }

  box.appendChild(frag);

  if (keepPos) {
    box.scrollTop = box.scrollHeight - prevH;     // anchor after prepend
  } else if (autoScroll) {
    box.scrollTop = box.scrollHeight;             // stick to bottom
  }
}

// fetch older (next page up). Prepends into cache. Respects MAX_CACHE by trimming from the NEWEST end.
async function loadOlderPage() {
  if (!hasMoreOlder || isLoadingOlder) return;
  isLoadingOlder = true;

  try {
    let q = db.collection('messages')
      .where('room', '==', currentRoom)
      .orderBy('timestamp', 'desc')
      .limit(PAGE_SIZE);

    if (olderCursorDesc) q = q.startAfter(olderCursorDesc);

    const snap = await q.get();
    if (snap.empty) {
      hasMoreOlder = false;
      return;
    }

    // update desc cursor (oldest of this batch in DESC is the last doc)
    olderCursorDesc = snap.docs[snap.docs.length - 1];

    // convert to ASC, dedupe by id
    const chunkAsc = snap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .reverse()
      .filter(d => !knownIds.has(d.id));

    // prepend older
    if (chunkAsc.length) {
      chunkAsc.forEach(m => knownIds.add(m.id));
      messagesCache = [...chunkAsc, ...messagesCache];

      // hard cap (drop from the NEWEST end to preserve the user's scrolled-up view)
      if (messagesCache.length > MAX_CACHE) {
        const toRemove = messagesCache.length - MAX_CACHE;
        const removed = messagesCache.splice(messagesCache.length - toRemove, toRemove);
        removed.forEach(m => knownIds.delete(m.id));
      }

      renderMessages({ keepPos: true });
      // update DM seen markers if needed
      updateDmSeenMarkers();
    }
  } finally {
    isLoadingOlder = false;
  }
}

// attach/refresh everything for the current room
async function loadMessages() {
  // kill previous realtime
  if (unsubscribeMessages) { unsubscribeMessages(); unsubscribeMessages = null; }
  if (unsubscribeLatest) { unsubscribeLatest(); unsubscribeLatest = null; }

  messagesCache = [];
  knownIds = new Set();
  hasMoreOlder = true;
  olderCursorDesc = null;
  latestCursorAsc = null;

  const box = document.getElementById('messages');

  // scroll logic: up loads older, down enables auto-follow to newest
  box.onscroll = async () => {
    if (isNearTop(box)) {
      await loadOlderPage();
    }
    // if user scrolls near bottom, re-enable auto follow
    autoScroll = isNearBottom(box);
  };

  // 1) initial: newest 25
  let initQ = db.collection('messages')
    .where('room', '==', currentRoom)
    .orderBy('timestamp', 'desc')
    .limit(PAGE_SIZE);

  const initSnap = await initQ.get();

  if (initSnap.empty) {
    messagesCache = [];
    knownIds.clear();
    renderMessages(); // clears and sits at bottom
    latestCursorAsc = null;
  } else {
    olderCursorDesc = initSnap.docs[initSnap.docs.length - 1]; // oldest of DESC batch
    const newestDoc = initSnap.docs[0];                        // newest of DESC batch
    latestCursorAsc = newestDoc;

    // seed cache in ASC + dedupe set
    messagesCache = initSnap.docs.map(d => ({ id: d.id, ...d.data() })).reverse();
    messagesCache.forEach(m => knownIds.add(m.id));

    autoScroll = true;
    renderMessages();
  }

  // 2) realtime for messages newer than current newest (ASC)
  let liveQ = db.collection('messages')
    .where('room', '==', currentRoom)
    .orderBy('timestamp', 'asc');

  if (latestCursorAsc) liveQ = liveQ.startAfter(latestCursorAsc);

  unsubscribeLatest = liveQ.onSnapshot((snap) => {
    if (snap.empty) return;

    latestCursorAsc = snap.docs[snap.docs.length - 1];

    // append new items, dedupe
    const additions = snap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .filter(d => !knownIds.has(d.id));

    if (!additions.length) return;

    additions.forEach(m => knownIds.add(m.id));
    messagesCache = [...messagesCache, ...additions];

    // cap: when appending, trim from the OLDEST end
    if (messagesCache.length > MAX_CACHE) {
      const toRemove = messagesCache.length - MAX_CACHE;
      const removed = messagesCache.splice(0, toRemove);
      removed.forEach(m => knownIds.delete(m.id));
    }

    renderMessages({ keepPos: false });
    updateDmSeenMarkers();
  });

  // hook up DM extras for current room (typing + seen)
  initDmExtrasForRoom();
}

    // ===== DM EXTRAS: typing indicator + seen receipts (RTDB) =====
// RTDB paths used:
//   typing/{roomId}/{uid}: boolean
//   reads/{roomId}/{uid}: serverTimeMillis

let typingTimer = null;
let unsubTyping = null;
let readsInterval = null;
let dmTypingInputHandler = null;

function markDmSeenNow(){
  if (!currentUser || currentRoom === 'public') return;
  const box = document.getElementById('messages');
  // Only mark seen when you’re caught up to the bottom
  if (!box || (box.scrollHeight - box.scrollTop - box.clientHeight) > 80) return;
  const myRef = rtdb.ref(`reads/${currentRoom}/${currentUser.uid}`);
  myRef.set(firebase.database.ServerValue.TIMESTAMP);
}

function initDmReadsWatcher(){
  if (readsInterval) { clearInterval(readsInterval); readsInterval = null; }
  if (!currentUser || currentRoom === 'public') return;
  // ping “seen” while you’re at bottom and the room is focused
  readsInterval = setInterval(markDmSeenNow, 1500);
}

function updateDmSeenMarkers(){
  if (!currentUser || currentRoom === 'public') return;
  const otherUid = currentRoom.split('_').find(u => u !== currentUser.uid);
  if (!otherUid) return;
  const otherReadRef = rtdb.ref(`reads/${currentRoom}/${otherUid}`);
  otherReadRef.once('value').then(s => {
    const otherReadAt = s.val() || 0;

    // find newest message I sent
    let lastMine = null;
    for (let i = messagesCache.length - 1; i >= 0; i--){
      const m = messagesCache[i];
      if (m && m.uid === currentUser.uid && !m.type) { lastMine = m; break; }
    }
    if (!lastMine) return;

    const ts = lastMine.timestamp && typeof lastMine.timestamp.toMillis === 'function'
      ? lastMine.timestamp.toMillis()
      : (typeof lastMine.timestamp === 'number' ? lastMine.timestamp : 0);

    const tag = document.querySelector(`[data-seen-for="${lastMine.id}"]`);
    if (!tag) return;

    tag.textContent = (otherReadAt && ts && otherReadAt >= ts) ? 'Seen' : '';
  });
}

function initDmExtrasForRoom(){
  // cleanup previous listeners/timers
  if (unsubTyping) { try { unsubTyping.ref.off('value', unsubTyping.cb); } catch{} unsubTyping = null; }
  if (typingTimer) { clearTimeout(typingTimer); typingTimer = null; }
  if (readsInterval) { clearInterval(readsInterval); readsInterval = null; }

  // remove old input handler if present
  const input = document.getElementById('messageInput');
  if (dmTypingInputHandler && input) {
    input.removeEventListener('input', dmTypingInputHandler);
    dmTypingInputHandler = null;
  }

  if (!currentUser || currentRoom === 'public') {
    // clear any typing dot in header if we left a DM
    const dot = document.getElementById('typingDot');
    if (dot) dot.textContent = '';
    return;
  }

  const otherUid = currentRoom.split('_').find(u => u !== currentUser.uid);
  if (!otherUid) return;

  // --- Typing indicator ---
  const myRef = rtdb.ref(`typing/${currentRoom}/${currentUser.uid}`);
  const otherRef = rtdb.ref(`typing/${currentRoom}/${otherUid}`);

  // header “typing…” dot
  const headerRight = document.querySelector('.chat-header .right');
  let dot = document.getElementById('typingDot');
  if (!dot) {
    dot = document.createElement('span');
    dot.id = 'typingDot';
    dot.style.marginLeft = '.4rem';
    headerRight.appendChild(dot);
  }

  const typingCb = s => { dot.textContent = s.val() ? 'typing…' : ''; };
  otherRef.on('value', typingCb);
  unsubTyping = { ref: otherRef, cb: typingCb };

  if (input) {
    dmTypingInputHandler = () => {
      myRef.set(true);
      if (typingTimer) clearTimeout(typingTimer);
      typingTimer = setTimeout(() => myRef.set(false), 2000);
    };
    input.addEventListener('input', dmTypingInputHandler);
    input.addEventListener('keydown', dmTypingInputHandler);
  }

  // --- Seen receipts ---
  initDmReadsWatcher();
  markDmSeenNow();
  updateDmSeenMarkers();
}

// One-time: keep seen current when you scroll to bottom
(function initDmGlobalScrollHook(){
  const box = document.getElementById('messages');
  if (!box) return;
  box.addEventListener('scroll', () => {
    if (currentRoom !== 'public') {
      markDmSeenNow();
      updateDmSeenMarkers();
    }
  });
})();

// ===== Calls (WebRTC audio over Firebase RTDB) =====
let pc = null;
let localStream = null;
let remoteStream = null;
let callInterval = null;
let callStartAt = null;
let isCaller = false;
let callRefs = { offer: null, answer: null, myCands: null, otherCands: null, state: null };
let currentCallRoom = null;
let incomingCallCtx = null;
let globalOfferWatchers = {};
let globalStateWatchers = {};
let dmMsgWatchers = {};
let dmMsgLastDocId = {};

// Video/screen share state
let localVideoStream = null; // camera
let screenStream = null;     // screen share
let remoteVideoStream = null;
let videoSender = null;      // RTCRtpSender for video
let isSharingScreen = false;
let makingOffer = false;     // for renegotiation
let isPolite = false;        // simple glare mitigation
let renegoRefs = { offer: null, answer: null };

let rtcConfig = { iceServers: [{ urls: [
  'stun:stun.l.google.com:19302',
  'stun:stun1.l.google.com:19302'
] }], iceTransportPolicy: 'all' };

// Optional: allow admins to inject TURN/ICE servers from RTDB at settings/iceServers
// Expected format: either an array of RTCIceServer entries or a single object
// Example array entry: { urls: ['turn:turn.example.com:3478'], username: 'user', credential: 'pass' }
try {
  rtdb.ref('settings/iceServers').on('value', s => {
    const v = s.val();
    if (!v) return;
    const baseStuns = [{ urls: ['stun:stun.l.google.com:19302','stun:stun1.l.google.com:19302'] }];
    if (Array.isArray(v)) {
      rtcConfig.iceServers = [...baseStuns, ...v];
    } else if (typeof v === 'object') {
      rtcConfig.iceServers = [...baseStuns, v];
    }
  });
  rtdb.ref('settings/iceTransportPolicy').on('value', s => {
    const v = s.val();
    if (v === 'relay' || v === 'all') rtcConfig.iceTransportPolicy = v;
  });
} catch (e) { /* ignore optional config errors */ }

function dmOtherUid(){
  if (!currentUser || currentRoom === 'public') return null;
  const parts = currentRoom.split('_');
  return parts.find(u => u !== currentUser.uid) || null;
}

function showCallOverlay(){
  document.getElementById('callOverlay').classList.add('active');
  document.getElementById('callWidget').classList.remove('active');
  try { updateVideoStageVisibility(); } catch {}
}
function hideCallOverlay(){
  document.getElementById('callOverlay').classList.remove('active');
}
function showCallWidget(){
  document.getElementById('callWidget').classList.add('active');
}
function hideCallWidget(){
  document.getElementById('callWidget').classList.remove('active');
}

function formatDuration(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const m = Math.floor(s/60); const r = s%60;
  return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
}

function startTimer(){
  const set = () => {
    const now = Date.now();
    const d = callStartAt ? now - callStartAt : 0;
    const t = formatDuration(d);
    document.getElementById('callStatus').textContent = `in call · ${t}`;
    document.getElementById('widgetTimer').textContent = t;
  };
  set();
  callInterval = setInterval(set, 1000);
}
function stopTimer(){ if (callInterval) { clearInterval(callInterval); callInterval = null; } }

async function getMic(){
  if (localStream) return localStream;
  const prefMic = localStorage.getItem('prefMicId');
  const constraints = prefMic ? { audio: { deviceId: { exact: prefMic } } } : { audio: true };
  localStream = await navigator.mediaDevices.getUserMedia(constraints);
  try { await initDeviceSelectors(); } catch {}
  return localStream;
}

function cleanupCallListeners(){
  if (callRefs.offer) { callRefs.offer.off(); callRefs.offer = null; }
  if (callRefs.answer) { callRefs.answer.off(); callRefs.answer = null; }
  if (callRefs.myCands) { callRefs.myCands.off(); callRefs.myCands = null; }
  if (callRefs.otherCands) { callRefs.otherCands.off(); callRefs.otherCands = null; }
  if (callRefs.state) { callRefs.state.off(); callRefs.state = null; }
}

async function endCall(reason='ended'){
  try {
    rtdb.ref(`calls/${currentCallRoom}/state`).set({ by: currentUser?.uid || 'sys', state: reason, at: firebase.database.ServerValue.TIMESTAMP });
  } catch {}
  stopRingtone();
  stopTimer();
  hideCallOverlay();
  hideCallWidget();
  if (pc) { try { pc.getSenders().forEach(s=>s.track&&s.track.stop()); pc.close(); } catch{} pc=null; }
  if (localStream) { try { localStream.getTracks().forEach(t=>t.stop()); } catch{} localStream=null; }
  if (localVideoStream) { try { localVideoStream.getTracks().forEach(t=>t.stop()); } catch{} localVideoStream=null; }
  if (screenStream) { try { screenStream.getTracks().forEach(t=>t.stop()); } catch{} screenStream=null; }
  remoteStream=null;
  remoteVideoStream=null;
  videoSender=null;
  isSharingScreen=false;
  document.getElementById('remoteAudio').srcObject = null;
  const rv = document.getElementById('remoteVideo'); if (rv) rv.srcObject = null;
  const lv = document.getElementById('localVideo'); if (lv) lv.srcObject = null;
  cleanupCallListeners();
  // best-effort cleanup of signaling for this call
  if (currentCallRoom) {
    const base = rtdb.ref(`calls/${currentCallRoom}`);
    base.child('offer').remove();
    base.child('answer').remove();
    base.child('candidates').remove();
    base.child('renegotiate').remove();
  }
  currentCallRoom = null;
  isCaller = false;
  callStartAt = null;
  updateVideoStageVisibility();
}

function bindPeerEvents(){
  pc.onicecandidate = (e) => {
    if (e.candidate) {
      rtdb.ref(`calls/${currentCallRoom}/candidates/${currentUser.uid}`).push(e.candidate.toJSON());
    }
  };
  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'connected') {
      document.getElementById('callStatus').textContent = 'connected';
    }
    if (['failed','disconnected','closed'].includes(pc.connectionState)) {
      // give a brief grace period for transient disconnects before ending
      const state = pc.connectionState;
      setTimeout(() => {
        if (!pc || pc.connectionState !== state) return; // recovered
        endCall(state);
      }, 1500);
    }
  };
  pc.ontrack = (e) => {
    // Route audio tracks to hidden audio element; video tracks to remoteVideo element
    e.streams.forEach(stream => {
      stream.getTracks().forEach(t => {
        if (t.kind === 'audio') {
          if (!remoteStream) remoteStream = new MediaStream();
          remoteStream.addTrack(t);
          const audio = document.getElementById('remoteAudio');
          audio.srcObject = remoteStream;
          audio.volume = 1.0;
          const prefSpk = localStorage.getItem('prefSpkId');
          if (prefSpk && typeof audio.setSinkId === 'function') {
            audio.setSinkId(prefSpk).catch(()=>{});
          }
          audio.play && audio.play().catch(()=>{});
        } else if (t.kind === 'video') {
          if (!remoteVideoStream) remoteVideoStream = new MediaStream();
          remoteVideoStream.addTrack(t);
          const rv = document.getElementById('remoteVideo');
          rv.srcObject = remoteVideoStream;
          rv.play && rv.play().catch(()=>{});
          try {
            t.addEventListener('ended', ()=>{ try { remoteVideoStream && remoteVideoStream.removeTrack(t); } catch{}; updateVideoStageVisibility(); });
          } catch {}
        }
      });
    });
    updateVideoStageVisibility();
  };
}

function getVideoPrefs(){
  return {
    camDeviceId: localStorage.getItem('prefCamId') || undefined,
    videoRes: parseInt(localStorage.getItem('prefVideoRes')||'1080',10),
    videoFps: parseInt(localStorage.getItem('prefVideoFps')||'60',10),
    videoBitrateKbps: parseInt(localStorage.getItem('prefVideoBitrate')||'4500',10),
    screenRes: parseInt(localStorage.getItem('prefScreenRes')||'1080',10),
    screenFps: parseInt(localStorage.getItem('prefScreenFps')||'60',10)
  };
}

function initVideoSelectorsUI(){
  const prefs = getVideoPrefs();
  const vRes = document.getElementById('videoResSelect'); if (vRes) vRes.value = String(prefs.videoRes);
  const vFps = document.getElementById('videoFpsSelect'); if (vFps) vFps.value = String(prefs.videoFps);
  const vBr = document.getElementById('videoBitrate'); if (vBr) vBr.value = String(prefs.videoBitrateKbps);
  const sRes = document.getElementById('screenResSelect'); if (sRes) sRes.value = String(prefs.screenRes);
  const sFps = document.getElementById('screenFpsSelect'); if (sFps) sFps.value = String(prefs.screenFps);
}

async function getCameraStream(){
  const prefs = getVideoPrefs();
  const width = prefs.videoRes === 1080 ? 1920 : 1280;
  const height = prefs.videoRes === 1080 ? 1080 : 720;
  const fps = prefs.videoFps;
  const constraints = {
    video: {
      width: { ideal: width },
      height: { ideal: height },
      frameRate: { ideal: fps, max: fps },
      deviceId: prefs.camDeviceId ? { exact: prefs.camDeviceId } : undefined
    },
    audio: false
  };
  try {
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    return stream;
  } catch (e) {
    // fallback to default video
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    return stream;
  }
}

async function startCamera(){
  localVideoStream = await getCameraStream();
  const lv = document.getElementById('localVideo');
  lv.srcObject = localVideoStream; lv.play && lv.play().catch(()=>{});
  const track = localVideoStream.getVideoTracks()[0];
  if (!track) return;
  if (pc) {
    if (!videoSender) {
      const trans = pc.addTransceiver('video', { direction: 'sendrecv' });
      videoSender = trans.sender;
    }
    await videoSender.replaceTrack(track);
    await ensureRenegotiation();
    await applyVideoEncodingPrefs();
  }
  updateVideoStageVisibility();
}

async function stopCamera(){
  try { if (localVideoStream) localVideoStream.getTracks().forEach(t=>t.stop()); } catch{}
  localVideoStream = null;
  const lv = document.getElementById('localVideo'); lv.srcObject = null;
  if (videoSender && !isSharingScreen) {
    await videoSender.replaceTrack(null);
    await ensureRenegotiation();
  }
  updateVideoStageVisibility();
}

async function startScreenShare(){
  const prefs = getVideoPrefs();
  const width = prefs.screenRes === 1080 ? 1920 : 1280;
  const height = prefs.screenRes === 1080 ? 1080 : 720;
  const fps = prefs.screenFps;
  const constraints = { video: { frameRate: { ideal: fps, max: fps }, width: { ideal: width }, height: { ideal: height }, cursor: 'always' }, audio: false };
  try {
    screenStream = await navigator.mediaDevices.getDisplayMedia(constraints);
  } catch (e) {
    console.warn('getDisplayMedia failed', e);
    return;
  }
  isSharingScreen = true;
  const track = screenStream.getVideoTracks()[0];
  if (track) {
    const lv = document.getElementById('localVideo'); lv.srcObject = screenStream; lv.play && lv.play().catch(()=>{});
    if (!videoSender) {
      const trans = pc.addTransceiver('video', { direction: 'sendrecv' });
      videoSender = trans.sender;
    }
    await videoSender.replaceTrack(track);
    await ensureRenegotiation();
    await applyVideoEncodingPrefs(true);
  }
  // When user stops sharing via browser UI
  const onEnded = () => { stopScreenShare(); };
  track && track.addEventListener('ended', onEnded, { once:true });
  updateVideoStageVisibility();
}

async function stopScreenShare(){
  try { if (screenStream) screenStream.getTracks().forEach(t=>t.stop()); } catch{}
  screenStream = null; isSharingScreen = false;
  if (localVideoStream && videoSender) {
    await videoSender.replaceTrack(localVideoStream.getVideoTracks()[0]||null);
    await ensureRenegotiation();
    await applyVideoEncodingPrefs();
    const lv = document.getElementById('localVideo'); lv.srcObject = localVideoStream;
  } else {
    if (videoSender) { await videoSender.replaceTrack(null); await ensureRenegotiation(); }
    const lv = document.getElementById('localVideo'); lv.srcObject = null;
  }
  updateVideoStageVisibility();
}

async function applyVideoEncodingPrefs(isScreen=false){
  if (!videoSender) return;
  const params = videoSender.getParameters();
  if (!params.encodings) params.encodings = [{}];
  const prefs = getVideoPrefs();
  const kbps = Math.max(300, parseInt(prefs.videoBitrateKbps||'4500',10));
  params.encodings[0].maxBitrate = kbps * 1000;
  try { await videoSender.setParameters(params); } catch {}
  try {
    const track = (isScreen ? screenStream?.getVideoTracks()[0] : localVideoStream?.getVideoTracks()[0]);
    if (track) {
      const fps = isScreen ? getVideoPrefs().screenFps : getVideoPrefs().videoFps;
      await track.applyConstraints({ frameRate: { ideal: fps, max: fps } });
    }
  } catch {}
}

async function ensureRenegotiation(){
  if (!pc) return;
  try {
    await doNegotiation();
  } catch (e) { console.warn('renegotiation error', e); }
}

function setupRenegotiationChannel(){
  const other = dmOtherUid();
  isPolite = other && currentUser && String(currentUser.uid) > String(other);
  const base = rtdb.ref(`calls/${currentCallRoom}/renegotiate`);
  renegoRefs.offer = base.child(`inbox/${currentUser.uid}/offer`);
  renegoRefs.offer.on('value', async (s) => {
    const v = s.val();
    if (!v) return;
    try {
      if (pc.signalingState !== 'stable') {
        if (!isPolite) { return; }
      }
      await pc.setRemoteDescription(new RTCSessionDescription({ type:'offer', sdp: v.sdp }));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      const ansRef = base.child(`inbox/${v.from}/answer`);
      await ansRef.set({ sdp: answer.sdp, type: answer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
    } catch (e) { console.warn('negotiation offer error', e); }
    finally { renegoRefs.offer.set(null); }
  });
  renegoRefs.answer = base.child(`inbox/${currentUser.uid}/answer`);
  renegoRefs.answer.on('value', async (s) => {
    const v = s.val();
    if (!v) return;
    try {
      await pc.setRemoteDescription(new RTCSessionDescription({ type:'answer', sdp: v.sdp }));
    } catch (e) { console.warn('negotiation answer error', e); }
    finally { renegoRefs.answer.set(null); }
  });
}

async function doNegotiation(){
  if (!pc) return;
  const other = dmOtherUid();
  if (!other) return;
  const base = rtdb.ref(`calls/${currentCallRoom}/renegotiate`);
  const outRef = base.child(`inbox/${other}/offer`);
  try {
    makingOffer = true;
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await outRef.set({ sdp: offer.sdp, type: offer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  } catch (e) { console.warn('doNegotiation failed', e); }
  finally { makingOffer = false; }
}

async function startOutgoingCall(){
  if (!currentUser || currentRoom==='public') return alert('Open a DM to start a call.');
  if (pc) return; // already in a call
  currentCallRoom = currentRoom;
  isCaller = true;
  showCallOverlay();
  document.getElementById('callStatus').textContent = 'calling…';

  pc = new RTCPeerConnection(rtcConfig);
  bindPeerEvents();
  setupRenegotiationChannel();
  const mic = await getMic();
  mic.getTracks().forEach(t => pc.addTrack(t, mic));
  // Prepare a video transceiver for future camera/screen tracks
  const vTrans = pc.addTransceiver('video', { direction: 'sendrecv' });
  videoSender = vTrans.sender;

  const offer = await pc.createOffer({ offerToReceiveAudio: true });
  await pc.setLocalDescription(offer);

  const base = rtdb.ref(`calls/${currentCallRoom}`);
  await base.child('offer').set({ sdp: offer.sdp, type: offer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  await base.child('state').set({ state:'ringing', by: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  startRingtone();

  // listen for answer
  callRefs.answer = base.child('answer');
  callRefs.answer.on('value', async (s) => {
    const ans = s.val();
    if (ans && pc && !pc.currentRemoteDescription) {
      await pc.setRemoteDescription(new RTCSessionDescription({ type: ans.type, sdp: ans.sdp }));
      stopRingtone();
      callStartAt = Date.now();
      startTimer();
      document.getElementById('callStatus').textContent = 'connecting…';
    }
  });

  // ICE from other side
  const other = dmOtherUid();
  callRefs.otherCands = base.child(`candidates/${other}`);
  callRefs.otherCands.on('child_added', async (snap) => {
    const c = snap.val();
    try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch {}
  });

  // observe state for end
  callRefs.state = base.child('state');
  callRefs.state.on('value', (s)=>{
    const v = s.val();
    if (v && v.state==='ended') endCall('remote-ended');
  });
}

async function acceptIncomingCall(offer){
  if (pc) return; // busy
  currentCallRoom = currentRoom;
  isCaller = false;
  showCallOverlay();
  document.getElementById('callStatus').textContent = 'connecting…';
  stopRingtone();

  pc = new RTCPeerConnection(rtcConfig);
  bindPeerEvents();
  setupRenegotiationChannel();
  const mic = await getMic();
  mic.getTracks().forEach(t => pc.addTrack(t, mic));
  const vTrans = pc.addTransceiver('video', { direction: 'sendrecv' });
  videoSender = vTrans.sender;

  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  const base = rtdb.ref(`calls/${currentCallRoom}`);
  await base.child('answer').set({ sdp: answer.sdp, type: answer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  await base.child('state').set({ state:'connected', by: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  callStartAt = Date.now();
  startTimer();

  // receive ICE from other side
  const other = dmOtherUid();
  callRefs.otherCands = base.child(`candidates/${other}`);
  callRefs.otherCands.on('child_added', async (snap) => {
    const c = snap.val();
    try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch {}
  });

  // observe state for end
  callRefs.state = base.child('state');
  callRefs.state.on('value', (s)=>{
    const v = s.val();
    if (v && v.state==='ended') endCall('remote-ended');
  });
}

// Watch for incoming offers in the active DM room
function initCallWatcherForRoom(){
  cleanupCallListeners();
  if (currentRoom==='public' || !currentUser) return;
  const base = rtdb.ref(`calls/${currentRoom}`);
  currentCallRoom = currentRoom; // used for watcher path

  if (pc) {
    // During an active call, keep watching state to detect remote hangup
    callRefs.state = base.child('state');
    callRefs.state.on('value', (s)=>{
      const v = s.val();
      if (v && v.state==='ended') { stopRingtone(); endCall('remote-ended'); }
    });
    return;
  }

  // Not in a call: watch for incoming offers
  callRefs.offer = base.child('offer');
  callRefs.offer.on('value', async (s) => {
    const v = s.val();
    if (!v || pc) return; // nothing or already busy
    if (v.from === currentUser.uid) return; // my own offer
    // incoming call UI: styled modal
    const room = dmRooms.find(r=>r.id===currentRoom);
    const callerName = room ? room.name.replace(/^@/,'') : 'user';
    document.getElementById('incomingName').textContent = callerName;
    document.getElementById('incomingAvatar').textContent = (callerName[0]||'U').toUpperCase();
    incomingCallCtx = { roomId: currentRoom, offer: { type: v.type, sdp: v.sdp } };
    document.getElementById('incomingCallModal').classList.add('active');
    startRingtone();
  });
  // watch state to stop ring if caller cancels before accept
  callRefs.state = base.child('state');
  callRefs.state.on('value', (s)=>{
    const v = s.val();
    if (v && v.state==='ended' && incomingCallCtx && incomingCallCtx.roomId === currentRoom) {
      document.getElementById('incomingCallModal').classList.remove('active');
      incomingCallCtx = null; stopRingtone();
    }
  });
}

// UI bindings
document.getElementById('startCallBtn').addEventListener('click', startOutgoingCall);
document.getElementById('hangupBtn').addEventListener('click', () => endCall('ended'));
document.getElementById('widgetHangupBtn').addEventListener('click', () => endCall('ended'));
document.getElementById('minimizeCallBtn').addEventListener('click', () => { hideCallOverlay(); showCallWidget(); });
document.getElementById('restoreCallBtn').addEventListener('click', () => { showCallOverlay(); hideCallWidget(); });
document.getElementById('toggleMicBtn').addEventListener('click', () => {
  if (!localStream) return;
  const track = localStream.getAudioTracks()[0];
  if (!track) return;
  track.enabled = !track.enabled;
  const icon = document.querySelector('#toggleMicBtn i');
  if (track.enabled) { icon.className = 'bx bx-microphone'; document.getElementById('toggleMicBtn').title = 'Mute mic'; }
  else { icon.className = 'bx bx-microphone-off'; document.getElementById('toggleMicBtn').title = 'Unmute mic'; }
});
document.getElementById('toggleVideoBtn').addEventListener('click', async () => {
  const btn = document.getElementById('toggleVideoBtn');
  const icon = btn.querySelector('i');
  if (!localVideoStream && !isSharingScreen) {
    await startCamera();
    icon.className = 'bx bx-video-off'; btn.title = 'Turn off camera';
    return;
  }
  if (isSharingScreen) {
    await stopScreenShare();
    icon.className = localVideoStream ? 'bx bx-video-off' : 'bx bx-video';
    btn.title = localVideoStream ? 'Turn off camera' : 'Turn on camera';
    return;
  }
  await stopCamera();
  icon.className = 'bx bx-video'; btn.title = 'Turn on camera';
});
document.getElementById('shareScreenBtn').addEventListener('click', async () => {
  const btn = document.getElementById('shareScreenBtn');
  const icon = btn.querySelector('i');
  if (!isSharingScreen) {
    await startScreenShare();
    if (isSharingScreen) { icon.className = 'bx bx-stop'; btn.title = 'Stop sharing'; }
  } else {
    await stopScreenShare();
    icon.className = 'bx bx-desktop'; btn.title = 'Share your screen';
  }
});
document.getElementById('callSettingsBtn').addEventListener('click', async () => {
  document.getElementById('callSettingsModal').classList.add('active');
  try { await initDeviceSelectors(); } catch {}
});
document.getElementById('closeCallSettingsBtn').addEventListener('click', () => {
  document.getElementById('callSettingsModal').classList.remove('active');
});

// Device selectors: mic and speaker
async function initDeviceSelectors(){
  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
  const devices = await navigator.mediaDevices.enumerateDevices();
  const inputs = devices.filter(d=>d.kind==='audioinput');
  const outputs = devices.filter(d=>d.kind==='audiooutput');
  const micSel = document.getElementById('micSelect');
  const spkSel = document.getElementById('spkSelect');
  if (micSel){
    const prefMic = localStorage.getItem('prefMicId');
    micSel.innerHTML = '';
    inputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId; opt.textContent = d.label || `Microphone ${micSel.length+1}`;
      if (prefMic && d.deviceId===prefMic) opt.selected = true;
      micSel.appendChild(opt);
    });
    micSel.onchange = async ()=>{
      const id = micSel.value; localStorage.setItem('prefMicId', id);
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: id } } });
        const newTrack = newStream.getAudioTracks()[0];
        if (pc) {
          const sender = pc.getSenders().find(s=>s.track && s.track.kind==='audio');
          if (sender) await sender.replaceTrack(newTrack);
        }
        if (localStream) localStream.getTracks().forEach(t=>t.stop());
        localStream = newStream;
      } catch(e) { console.warn('mic switch failed', e); }
    };
  }
  if (spkSel){
    const prefSpk = localStorage.getItem('prefSpkId');
    spkSel.innerHTML = '';
    outputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId; opt.textContent = d.label || `Speaker ${spkSel.length+1}`;
      if (prefSpk && d.deviceId===prefSpk) opt.selected = true;
      spkSel.appendChild(opt);
    });
    if (typeof document.getElementById('remoteAudio').setSinkId !== 'function') {
      // Speaker selection unsupported; hide just the label + select
      const label = spkSel.previousElementSibling;
      if (label) label.style.display = 'none';
      spkSel.style.display = 'none';
    } else {
      spkSel.onchange = async ()=>{
        const id = spkSel.value; localStorage.setItem('prefSpkId', id);
        try { await document.getElementById('remoteAudio').setSinkId(id); } catch(e){ console.warn('setSinkId failed', e);} 
      };
    }
  }
  // refresh lists when devices change
  navigator.mediaDevices.ondevicechange = async ()=>{
    try { await initDeviceSelectors(); } catch{}
  };

  // Populate camera select
  const devices2 = await navigator.mediaDevices.enumerateDevices();
  const cams = devices2.filter(d=>d.kind==='videoinput');
  const camSel = document.getElementById('camSelect');
  if (camSel){
    const prefCam = localStorage.getItem('prefCamId');
    camSel.innerHTML = '';
    cams.forEach((d, idx)=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId; opt.textContent = d.label || `Camera ${idx+1}`;
      if (prefCam && d.deviceId===prefCam) opt.selected = true;
      camSel.appendChild(opt);
    });
    camSel.onchange = async ()=>{
      const id = camSel.value; localStorage.setItem('prefCamId', id);
      if (localVideoStream) {
        try {
          const prefs = getVideoPrefs();
          const width = prefs.videoRes===1080?1920:1280; const height = prefs.videoRes===1080?1080:720; const fps = prefs.videoFps;
          const newStream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: id }, width: { ideal: width }, height: { ideal: height }, frameRate: { ideal: fps, max: fps } } });
          const newTrack = newStream.getVideoTracks()[0];
          if (videoSender) await videoSender.replaceTrack(newTrack);
          localVideoStream.getTracks().forEach(t=>t.stop());
          localVideoStream = newStream;
          document.getElementById('localVideo').srcObject = newStream;
          await ensureRenegotiation();
        } catch(e){ console.warn('camera switch failed', e); }
      }
    };
  }

  // Hook video settings to localStorage and live updates
  ['videoResSelect','videoFpsSelect','videoBitrate','screenResSelect','screenFpsSelect'].forEach(id=>{
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', ()=>{
      if (id==='videoResSelect') localStorage.setItem('prefVideoRes', el.value);
      if (id==='videoFpsSelect') localStorage.setItem('prefVideoFps', el.value);
      if (id==='videoBitrate') localStorage.setItem('prefVideoBitrate', el.value);
      if (id==='screenResSelect') localStorage.setItem('prefScreenRes', el.value);
      if (id==='screenFpsSelect') localStorage.setItem('prefScreenFps', el.value);
      if (id==='videoBitrate') applyVideoEncodingPrefs(isSharingScreen);
    });
  });
  initVideoSelectorsUI();
}

function updateVideoStageVisibility(){
  const stage = document.getElementById('videoStage');
  if (!stage) return;
  const localOn = !!(localVideoStream && typeof localVideoStream.getVideoTracks === 'function' && localVideoStream.getVideoTracks().some(t=>t.readyState==='live'));
  const screenOn = !!(isSharingScreen && screenStream && typeof screenStream.getVideoTracks === 'function' && screenStream.getVideoTracks().some(t=>t.readyState==='live'));
  const remoteOn = !!(remoteVideoStream && typeof remoteVideoStream.getVideoTracks === 'function' && remoteVideoStream.getVideoTracks().some(t=>t.readyState==='live'));
  if (localOn || screenOn || remoteOn) stage.classList.remove('hidden');
  else stage.classList.add('hidden');
}

// incoming call modal buttons
document.getElementById('acceptCallBtn').addEventListener('click', async ()=>{
  const ctx = incomingCallCtx; incomingCallCtx = null;
  document.getElementById('incomingCallModal').classList.remove('active');
  if (!ctx) return;
  if (currentRoom !== ctx.roomId) switchRoom(ctx.roomId);
  await acceptIncomingCall(ctx.offer);
});
document.getElementById('declineCallBtn').addEventListener('click', async ()=>{
  const ctx = incomingCallCtx; incomingCallCtx = null;
  document.getElementById('incomingCallModal').classList.remove('active');
  if (!ctx) return;
  stopRingtone();
  const base = rtdb.ref(`calls/${ctx.roomId}`);
  await base.child('state').set({ state:'ended', by: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  // missed call system message
  const other = ctx.roomId.split('_').find(u=>u!==currentUser.uid);
  const otherDoc = await db.collection('users').doc(other).get();
  const otherName = otherDoc.exists ? otherDoc.data().username : 'user';
  await db.collection('messages').add({ type:'system', text:`Missed call from @${otherName}`, room: ctx.roomId, timestamp: Date.now() });
});

// Ensure typing=false when closing the page
window.addEventListener('beforeunload', () => {
  if (!currentUser || currentRoom === 'public') return;
  rtdb.ref(`typing/${currentRoom}/${currentUser.uid}`).set(false);
});

// ===== DM desktop notifications + sound =====
function beep(kind='msg'){
  try {
    if (localStorage.getItem('soundNotifications') === 'false') return;
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = 'sine'; o.frequency.value = (kind==='ring' ? 660 : 880);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.2);
    o.connect(g); g.connect(ctx.destination); o.start(); o.stop(ctx.currentTime+0.22);
  } catch {}
}

function notifyDm(roomId, title, body){
  const desktopEnabled = localStorage.getItem('desktopNotifications') === 'true';
  if (!desktopEnabled || !('Notification' in window)) return;
  if (Notification.permission !== 'granted') return;
  const n = new Notification(title, { body, icon: '../logo.png', tag: `dm-${roomId}` });
  n.onclick = () => { try { window.focus(); switchRoom(roomId); } catch{} };
}

// Subtle two-tone ringtone loop for calls
let ringCtx = null;
let ringInterval = null;
function startRingtone(){
  if (localStorage.getItem('soundNotifications') === 'false') return;
  if (ringInterval) return;
  try { ringCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch { return; }
  const playNote = (freq, dur=0.22, gain=0.18, type='sine', delay=0)=>{
    try {
      const o = ringCtx.createOscillator(); const g = ringCtx.createGain();
      o.type = type; o.frequency.value = freq; g.gain.value = 0.0001;
      o.connect(g); g.connect(ringCtx.destination);
      const t = ringCtx.currentTime + delay;
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(gain, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.start(t); o.stop(t+dur+0.02);
    } catch {}
  };
  // pattern: soft arpeggio + short tick
  const pattern = () => {
    playNote(740, 0.20, 0.16, 'sine', 0.00); // F#5
    playNote(659, 0.18, 0.14, 'sine', 0.22); // E5
    playNote(587, 0.18, 0.14, 'sine', 0.42); // D5
    playNote(880, 0.16, 0.12, 'triangle', 0.62); // A5 ping
    // soft low tick for texture
    playNote(180, 0.08, 0.08, 'sine', 0.80);
  };
  pattern();
  ringInterval = setInterval(pattern, 1300);
}
function stopRingtone(){
  if (ringInterval) { clearInterval(ringInterval); ringInterval=null; }
  if (ringCtx) { try { ringCtx.close(); } catch {} ringCtx=null; }
}

function cleanupDmNotificationWatchers(){
  Object.values(dmMsgWatchers).forEach(unsub=>{ try{unsub();}catch{} });
  dmMsgWatchers = {}; // do not reset dmMsgLastDocId to preserve last seen across reinit
}

function initDmNotificationWatchers(){
  cleanupDmNotificationWatchers();
  if (!currentUser || !Array.isArray(dmRooms)) return;
  dmRooms.forEach(room => {
    const q = db.collection('messages').where('room','==',room.id).orderBy('timestamp','desc').limit(1);
    dmMsgWatchers[room.id] = q.onSnapshot((snap)=>{
      if (snap.empty) return;
      const doc = snap.docs[0];
      if (dmMsgLastDocId[room.id] === doc.id) return; // ignore repeats
      dmMsgLastDocId[room.id] = doc.id;
      const m = doc.data();
      if (m.type==='system') return;
      if (!currentUser || m.uid === currentUser.uid) return;
      // only notify if message is not in the active room or tab not focused
      if (document.hidden || currentRoom !== room.id) {
        notifyDm(room.id, `${room.name} sent a message`, m.text || 'New message');
        beep('msg');
        unreadDMs[room.id] = true; renderRoomTabs();
      }
    });
  });
}

function cleanupGlobalCallWatchers(){
  Object.values(globalOfferWatchers).forEach(ref => { try{ ref.off(); }catch{} });
  globalOfferWatchers = {};
  Object.values(globalStateWatchers).forEach(ref => { try{ ref.off(); }catch{} });
  globalStateWatchers = {};
}

function initGlobalCallWatchers(){
  cleanupGlobalCallWatchers();
  if (!currentUser || !Array.isArray(dmRooms)) return;
  dmRooms.forEach(room => {
    const ref = rtdb.ref(`calls/${room.id}/offer`);
    ref.on('value', (s)=>{
      const v = s.val();
      if (!v) return;
      if (v.from === currentUser.uid) return;
      if (pc) return; // already on a call
      // if offer arrives in a different room than current, show modal
      if (room.id !== currentRoom) {
        const name = room.name.replace(/^@/, '');
        document.getElementById('incomingName').textContent = name;
        document.getElementById('incomingAvatar').textContent = (name[0]||'U').toUpperCase();
        incomingCallCtx = { roomId: room.id, offer: { type:v.type, sdp:v.sdp } };
        document.getElementById('incomingCallModal').classList.add('active');
        startRingtone();
        // temporary state watcher for this room to stop ring if caller cancels
        const sref = rtdb.ref(`calls/${room.id}/state`);
        sref.on('value', (sv)=>{
          const st = sv.val();
          if (st && st.state==='ended' && incomingCallCtx && incomingCallCtx.roomId===room.id) {
            document.getElementById('incomingCallModal').classList.remove('active');
            incomingCallCtx=null; stopRingtone();
          }
        });
        globalStateWatchers[room.id] = sref;
      }
    });
    globalOfferWatchers[room.id] = ref;
  });
}
// Draggable minimized call widget with snapping
(function initCallWidgetDrag(){
  const widget = document.getElementById('callWidget');
  if (!widget) return;
  let dragging=false, startX=0, startY=0, orig={x:0,y:0};
  function applyCorner(c){
    widget.style.top = widget.style.right = widget.style.bottom = widget.style.left = '';
    if (c==='tl'){ widget.style.top='80px'; widget.style.left='20px'; }
    if (c==='tr'){ widget.style.top='80px'; widget.style.right='20px'; }
    if (c==='bl'){ widget.style.bottom='20px'; widget.style.left='20px'; }
    if (c==='br'){ widget.style.bottom='20px'; widget.style.right='20px'; }
    localStorage.setItem('callWidgetCorner', c);
  }
  applyCorner(localStorage.getItem('callWidgetCorner')||'tl');
  function onDown(e){
    dragging=true; widget.style.transition='none'; widget.style.cursor='grabbing';
    const r=widget.getBoundingClientRect(); orig={x:r.left,y:r.top};
    startX=(e.touches?e.touches[0].clientX:e.clientX);
    startY=(e.touches?e.touches[0].clientY:e.clientY);
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchmove', onMove, {passive:false});
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchend', onUp);
    e.preventDefault();
  }
  function onMove(e){
    if(!dragging) return;
    const x=(e.touches?e.touches[0].clientX:e.clientX);
    const y=(e.touches?e.touches[0].clientY:e.clientY);
    const dx=x-startX, dy=y-startY;
    widget.style.left=(orig.x+dx)+'px'; widget.style.top=(orig.y+dy)+'px';
    widget.style.right=''; widget.style.bottom='';
  }
  function onUp(){
    if(!dragging) return; dragging=false;
    widget.style.transition='top .2s ease, left .2s ease, right .2s ease, bottom .2s ease'; widget.style.cursor='grab';
    const r=widget.getBoundingClientRect(); const vw=window.innerWidth, vh=window.innerHeight;
    const d={ tl:Math.hypot(r.left-20,r.top-80), tr:Math.hypot(vw-r.right-20,r.top-80), bl:Math.hypot(r.left-20,vh-r.bottom-20), br:Math.hypot(vw-r.right-20,vh-r.bottom-20)};
    const best=Object.entries(d).sort((a,b)=>a[1]-b[1])[0][0];
    applyCorner(best);
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mouseup', onUp);
    document.removeEventListener('touchend', onUp);
  }
  widget.addEventListener('mousedown', onDown);
  widget.addEventListener('touchstart', onDown, {passive:false});
})();
    
    function loadOnlineUsers() {
      db.collection('users').where('online', '==', true).onSnapshot((snapshot) => {
        const usersDiv = document.getElementById('usersList');
        usersDiv.innerHTML = '';

        snapshot.forEach((doc) => {
          const user = doc.data();
          if (user.showOnlineStatus === false) return; // respect privacy toggle
          const userEl = document.createElement('div');
          userEl.className = 'user-row';
          userEl.innerHTML = `
            <div>
              <div class="user-name">${user.username}${user.isAdmin ? '<span class="badge-admin">ADMIN</span>' : ''}</div>
              <div class="user-meta"><span class="status-dot online"></span>online</div>
            </div>
          `;
          userEl.addEventListener('click', () => showProfile(user));
          usersDiv.appendChild(userEl);
        });
      });
    }

    function showProfile(user) {
      document.getElementById('profileModal').classList.add('active');
      document.getElementById('profileAvatar').textContent = user.username[0].toUpperCase();
      document.getElementById('profileUsername').textContent = user.username;
      document.getElementById('profileStatus').textContent = user.online ? 'online' : 'offline';
      document.getElementById('profileBio').textContent = user.bio || 'no bio set';
    }

    document.getElementById('sendBtn').addEventListener('click', sendMessage);
    document.getElementById('messageInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); sendMessage(); }
  });

    async function sendMessage() {
  const input = document.getElementById('messageInput');
  const textRaw = (input.value || '');
  const text = textRaw.trim();
  if (!text) return;
  if (!currentUser) { alert('Sign in to chat.'); return; }

  // Admin commands first (should work even during shutdown/lockdown)
  if (text.startsWith('/') && !!currentUser.isAdmin) {
    await handleAdminCommand(text);
    input.value = '';
    return;
  }

  // Global switches
  if (settings.chatShutdown) { alert('Chat is shut down by an admin.'); return; }
  if (settings.lockdown && !currentUser.isAdmin) { alert('Chat is in lockdown.'); return; }

  // Fresh read of user record to avoid stale state
  const meDoc = await db.collection('users').doc(currentUser.uid).get();
  const me = meDoc.exists ? meDoc.data() : currentUser;

  if (me.isBanned) {
    document.getElementById('banModal').classList.add('active');
    document.getElementById('banReason').textContent = me.banReason || 'You have been banned from chat.';
    await auth.signOut();
    return;
  }

  if (me.isMuted) {
    const untilMs =
      typeof me.muteUntil === 'number' ? me.muteUntil :
      (me.muteUntil && typeof me.muteUntil.toMillis === 'function' ? me.muteUntil.toMillis() : 0);
    const remaining = untilMs ? Math.max(0, Math.ceil((untilMs - Date.now()) / 1000)) : null;
    alert(remaining ? `You are muted for ${remaining} more second(s).` : 'You are muted.');
    return;
  }

  // Content checks
  if (containsOffensive(text)) { alert('Message blocked by content filter.'); return; }

  // Slow mode (per device, backed by RTDB setting)
  if (settings.slowMode > 0 && !me.isAdmin) {
    const elapsed = (nowMs() - (settings.lastSentAt || 0)) / 1000;
    if (elapsed < settings.slowMode) {
      alert(`Slow mode is on. Wait ${Math.ceil(settings.slowMode - elapsed)}s.`);
      return;
    }
  }

  // Simple anti-spam: identical message within 3s
  const nowLocal = nowMs();
  if (text === lastMessage && (nowLocal - lastMessageTime) < 3000) {
    alert('Please do not spam the same message.');
    return;
  }

  // Build & send message with serverTimestamp (authoritative ordering)
  const messageData = {
    uid: currentUser.uid,
    username: currentUser.username,
    isAdmin: !!currentUser.isAdmin,
    text,
    room: currentRoom,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  };

  if (replyingTo) {
    messageData.replyTo = replyingTo;
    replyingTo = null;
    document.getElementById('replyIndicator').classList.remove('active');
  }

  await db.collection('messages').add(messageData);

  // Local bookkeeping
  settings.lastSentAt = nowLocal;
  lastMessage = text;
  lastMessageTime = nowLocal;
  input.value = '';
}

    async function handleAdminCommand(command) {
      const parts = command.split(' ');
      const cmd = parts[0].toLowerCase();
      const args = parts.slice(1);

      console.log('[v0] Admin command:', cmd, args);

      try {
        switch(cmd) {
          case '/ban':
            if (args.length < 1) {
              alert('Usage: /ban <username> [reason]');
              return;
            }
            await banUser(args[0], args.slice(1).join(' ') || 'No reason provided');
            break;

          case '/unban':
            if (args.length < 1) {
              alert('Usage: /unban <username>');
              return;
            }
            await unbanUser(args[0]);
            break;

          case '/kick':
            if (args.length < 1) {
              alert('Usage: /kick <username>');
              return;
            }
            await kickUser(args[0]);
            break;

          case '/mute':
            if (args.length < 2) {
              alert('Usage: /mute <username> <minutes>');
              return;
            }
            await muteUser(args[0], parseInt(args[1]));
            break;

          case '/unmute':
            if (args.length < 1) {
              alert('Usage: /unmute <username>');
              return;
            }
            await unmuteUser(args[0]);
            break;

          case '/clear':
            await clearChat();
            break;

          case '/announce':
            if (args.length < 1) {
              alert('Usage: /announce <message>');
              return;
            }
            await sendAnnouncement(args.join(' '));
            break;

          case '/warn':
            if (args.length < 2) {
              alert('Usage: /warn <username> <message>');
              return;
            }
            await warnUser(args[0], args.slice(1).join(' '));
            break;

          case '/promote':
            if (args.length < 1) {
              alert('Usage: /promote <username>');
              return;
            }
            await promoteUser(args[0]);
            break;

          case '/demote':
            if (args.length < 1) {
              alert('Usage: /demote <username>');
              return;
            }
            await demoteUser(args[0]);
            break;

          case '/shutdown':
            await shutdownChat();
            break;

          case '/restart':
            await restartChat();
            break;

          case '/slowmode':
            if (args.length < 1) {
              alert('Usage: /slowmode <seconds>');
              return;
            }
            await setSlowMode(parseInt(args[0]));
            break;

          case '/lockdown':
            await toggleLockdown();
            break;

          case '/purge':
            if (args.length < 1) {
              alert('Usage: /purge <username>');
              return;
            }
            await purgeUserMessages(args[0]);
            break;

          case '/stats':
            await showStats();
            break;

          case '/help':
            showAdminHelp();
            break;

          default:
            alert(`Unknown command: ${cmd}\nType /help for a list of commands`);
        }
      } catch (error) {
        console.error('[v0] Command error:', error);
        alert(`Error executing command: ${error.message}`);
      }
    }

    async function banUser(username, reason) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({
        isBanned: true,
        banReason: reason,
        bannedBy: currentUser.username,
        bannedAt: Date.now()
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been banned by ${currentUser.username}. Reason: ${reason}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been banned`);
    }

    async function unbanUser(username) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({
        isBanned: false,
        banReason: null,
        bannedBy: null,
        bannedAt: null
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been unbanned by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been unbanned`);
    }

    async function kickUser(username) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({ online: false });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been kicked by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been kicked`);
    }

    async function muteUser(username, minutes) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      const muteUntil = Date.now() + (minutes * 60 * 1000);
      
      await db.collection('users').doc(userDoc.id).update({
        isMuted: true,
        muteUntil: muteUntil,
        mutedBy: currentUser.username
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been muted for ${minutes} minutes by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been muted for ${minutes} minutes`);
    }

    async function unmuteUser(username) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({
        isMuted: false,
        muteUntil: null,
        mutedBy: null
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been unmuted by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been unmuted`);
    }

    async function clearChat() {
      const messagesQuery = await db.collection('messages').where('room', '==', currentRoom).get();
      const batch = db.batch();
      messagesQuery.docs.forEach(doc => batch.delete(doc.ref));
      await batch.commit();

      await db.collection('messages').add({
        type: 'system',
        text: `Chat cleared by ${currentUser.username}`,
        room: currentRoom,
        timestamp: Date.now()
      });

      alert('Chat has been cleared');
    }

    async function sendAnnouncement(message) {
      await db.collection('messages').add({
        type: 'system',
        text: `📢 ANNOUNCEMENT: ${message}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert('Announcement sent');
    }

    async function warnUser(username, message) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      await db.collection('messages').add({
        type: 'system',
        text: `⚠️ ${username} has been warned by ${currentUser.username}: ${message}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`Warning sent to ${username}`);
    }

    async function promoteUser(username) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({ isAdmin: true });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been promoted to admin by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been promoted to admin`);
    }

    async function demoteUser(username) {
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({ isAdmin: false });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been demoted by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been demoted`);
    }

    async function shutdownChat() {
      await rtdb.ref('settings/chatShutdown').set(true);
      
      await db.collection('messages').add({
        type: 'system',
        text: `🔒 Chat has been shut down by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert('Chat has been shut down');
    }

    async function restartChat() {
      await rtdb.ref('settings/chatShutdown').set(false);
      
      await db.collection('messages').add({
        type: 'system',
        text: `✅ Chat has been restarted by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert('Chat has been restarted');
    }

    async function setSlowMode(seconds) {
      await rtdb.ref('settings/slowMode').set(seconds);
      
      await db.collection('messages').add({
        type: 'system',
        text: `⏱️ Slow mode set to ${seconds} seconds by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`Slow mode set to ${seconds} seconds`);
    }

    async function toggleLockdown() {
      const lockdownRef = rtdb.ref('settings/lockdown');
      const snapshot = await lockdownRef.once('value');
      const isLocked = snapshot.val() || false;
      
      await lockdownRef.set(!isLocked);
      
      await db.collection('messages').add({
        type: 'system',
        text: `🔐 Lockdown ${!isLocked ? 'enabled' : 'disabled'} by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`Lockdown ${!isLocked ? 'enabled' : 'disabled'}`);
    }

    async function purgeUserMessages(username) {
      const messagesQuery = await db.collection('messages').where('username', '==', username).get();
      const batch = db.batch();
      messagesQuery.docs.forEach(doc => batch.delete(doc.ref));
      await batch.commit();

      await db.collection('messages').add({
        type: 'system',
        text: `All messages from ${username} have been purged by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`All messages from ${username} have been purged`);
    }

    async function showStats() {
      const usersSnapshot = await db.collection('users').get();
      const messagesSnapshot = await db.collection('messages').get();
      const onlineUsers = usersSnapshot.docs.filter(doc => doc.data().online).length;
      
      alert(`
📊 Chat Statistics:
Total Users: ${usersSnapshot.size}
Online Users: ${onlineUsers}
Total Messages: ${messagesSnapshot.size}
Current Room: ${currentRoom}
      `);
    }

    function showAdminHelp() {
      alert(`
🛠️ Admin Commands:
/ban <user> [reason] - Ban a user
/unban <user> - Unban a user
/kick <user> - Kick a user
/mute <user> <minutes> - Mute a user
/unmute <user> - Unmute a user
/warn <user> <message> - Warn a user
/promote <user> - Promote to admin
/demote <user> - Demote from admin
/clear - Clear chat messages
/purge <user> - Delete all user messages
/announce <message> - Send announcement
/slowmode <seconds> - Set slow mode
/lockdown - Toggle lockdown mode
/shutdown - Shutdown chat
/restart - Restart chat
/stats - Show statistics
/help - Show this help
      `);
    }

    window.addEventListener('beforeunload', () => {
      if (currentUser) {
        db.collection('users').doc(currentUser.uid).update({ online: false });
      }
    });

    document.getElementById('showSignUpBtn').addEventListener('click', () => {
      document.getElementById('signInForm').style.display = 'none';
      document.getElementById('signUpForm').style.display = 'block';
    });

    document.getElementById('showSignInBtn').addEventListener('click', () => {
      document.getElementById('signUpForm').style.display = 'none';
      document.getElementById('signInForm').style.display = 'block';
    });
    
    // Clean up any active call when leaving the page
    window.addEventListener('beforeunload', () => {
      if (pc) {
        try { endCall('unload'); } catch {}
      }
    });
  </script>
</body>
</html>
