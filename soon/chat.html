<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8NN9RRBJ8H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8NN9RRBJ8H');
</script>
  <meta charset="utf-8" />
  <title>Polar's Shack — Chat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="../logo.png">
  <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">

  <!-- Environment config (generated) -->
  <script src="../env.js"></script>
  <script src="../env.fallback.js"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
:root {
  --bg:#111;
  --card:#1e1e1e;
  --muted:#666;
  --accent:#00ff00;
  --danger:#ff6666;
  --panel:#0f0f0f;
  --border:#333;
}
* { box-sizing: border-box; margin:0; padding:0; }
body {
  font-family:'JetBrains Mono', monospace;
  background:linear-gradient(180deg,#0b0b0b,var(--bg));
  color:#ddd;
  height:100vh;
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

/* Enhanced navbar with settings button */
.navbar {
  background:#1a1a1a;
  padding:1rem 1.5rem;
  border-bottom:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  position:sticky;
  top:0;
  z-index:60;
  backdrop-filter:blur(10px);
}
.logo-nav {display:flex;gap:.75rem;align-items:center;}
.logo-nav img {width:34px;height:34px;border-radius:6px;}
.logo-nav span {color:#fff;font-weight:600;font-size:1.1rem;}
.nav-links {display:flex;gap:1.5rem;align-items:center;}
.nav-links a {color:#aaa;text-decoration:none;padding:.4rem .6rem;border-radius:6px;transition:all .2s;}
.nav-links a.active, .nav-links a:hover {color:var(--accent);background:rgba(0,255,0,0.05);}
.nav-btn {background:#2a2a2a;border:1px solid var(--border);color:#aaa;padding:.5rem .9rem;border-radius:8px;cursor:pointer;transition:all .2s;font-family:'JetBrains Mono',monospace;font-size:.9rem;display:flex;align-items:center;gap:.5rem;}
.nav-btn:hover {background:#333;border-color:var(--accent);color:var(--accent);}

/* Three-column layout: users | chat | room-selector */
.layout {
  display:flex;
  height:calc(100vh - 70px);
  width:100%;
  overflow:hidden;
}

/* Users panel with profile click */
.users-panel {
  width:240px;
  background:var(--panel);
  border-right:1px solid var(--border);
  padding:.75rem;
  overflow-y:auto;
  box-shadow:0 6px 18px rgba(0,0,0,0.5);
}
.users-panel h3 {color:var(--accent);margin:.15rem 0 .75rem;font-size:1rem;text-transform:uppercase;letter-spacing:1px;}
.user-row {
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .7rem;
  border-radius:8px;
  transition:all .15s;
  cursor:pointer;
  border:1px solid transparent;
}
.user-row:hover {background:#151515;transform:translateY(-1px);border-color:var(--accent);}
.user-name {
  color:#fff;
  font-weight:600;
  font-size:.95rem;
  max-width:140px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.user-meta {font-size:.75rem;color:var(--muted);}
.badge-admin {color:var(--danger);font-weight:700;margin-left:.4rem;font-size:.75rem;}
.status-dot {
  width:8px;
  height:8px;
  border-radius:50%;
  display:inline-block;
  margin-right:.4rem;
}
.status-dot.online {background:var(--accent);box-shadow:0 0 8px var(--accent);}
.status-dot.offline {background:#444;}

/* Chat card with room switcher */
.chat-card {
  flex:1;
  display:flex;
  flex-direction:column;
  background:linear-gradient(180deg,#121212,#161616);
  border-left:1px solid var(--border);
  overflow:hidden;
  box-shadow:0 10px 30px rgba(0,0,0,0.6);
}
.chat-header {
  padding:1rem 1.25rem;
  border-bottom:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:1rem;
  background:#1a1a1a;
}
.chat-header .title {color:var(--accent);font-weight:700;font-size:1.1rem;}
.chat-header .right {font-size:.9rem;color:var(--muted);display:flex;gap:.75rem;align-items:center;}

/* gray icon button (matches nav-btn aesthetic but compact) */
.icon-btn {
  background:#2a2a2a;
  border:1px solid var(--border);
  color:#aaa;
  padding:.45rem .6rem;
  border-radius:8px;
  cursor:pointer;
  transition:all .2s;
  display:flex;
  align-items:center;
  gap:.4rem;
}
.icon-btn:hover {background:#333;border-color:var(--accent);color:var(--accent);} 
/* typing indicator styling */
#typingDot { color: var(--accent); opacity:.8; animation: typingBlink 1s ease-in-out infinite; }
@keyframes typingBlink { 0%{opacity:.35} 50%{opacity:1} 100%{opacity:.35} }

/* Room selector tabs */
.room-tabs {
  display:flex;
  gap:.5rem;
  padding:.75rem 1rem;
  background:#0f0f0f;
  border-bottom:1px solid var(--border);
  overflow-x:auto;
}
.room-tab {
  padding:.5rem 1rem;
  background:#2a2a2a;
  border:1px solid var(--border);
  border-radius:8px;
  color:#888;
  cursor:pointer;
  transition:all .2s;
  white-space:nowrap;
  font-size:.85rem;
  display:flex;
  align-items:center;
  gap:.5rem;
}
.room-tab.active {background:var(--accent);color:#000;border-color:var(--accent);font-weight:600;}
.room-tab:hover:not(.active) {background:#333;border-color:var(--accent);color:var(--accent);}
.room-tab .close-dm {
  margin-left:.3rem;
  opacity:.6;
  transition:opacity .2s;
}
.room-tab .close-dm:hover {opacity:1;}

/* Messages with reply support */
.messages {
  flex:1;
  padding:1rem;
  overflow-y:auto;
  display:flex;
  flex-direction:column;
  gap:.6rem;
  scroll-behavior:smooth;
  background:radial-gradient(1200px 200px at 10% 0%, rgba(0,255,0,0.01), transparent 2%),transparent;
}
.msg {
  max-width:75%;
  padding:.7rem .95rem;
  border-radius:12px;
  display:inline-block;
  line-height:1.3;
  animation:enter .2s ease;
  box-shadow:0 2px 8px rgba(0,0,0,0.5);
  position:relative;
}
.msg .meta {display:block;font-size:.8rem;color:var(--muted);margin-bottom:.3rem;display:flex;align-items:center;gap:.5rem;}
.msg .meta .username {font-weight:600;}
.msg .content {margin-top:.2rem;}
.msg.me {align-self:flex-end;background:var(--accent);color:#050505;border-bottom-right-radius:4px;}
.msg.other {align-self:flex-start;background:#1a1a1a;color:#ddd;border-bottom-left-radius:4px;border:1px solid var(--border);}
.msg.system {align-self:center;background:transparent;color:#888;font-style:italic;padding:.3rem .6rem;border-radius:6px;max-width:90%;}
.admin-tag {color:var(--danger);font-weight:700;margin-left:.45rem;font-size:.75rem;}

/* Reply preview in message */
.reply-preview {
  background:rgba(0,0,0,0.3);
  padding:.4rem .6rem;
  border-left:3px solid var(--accent);
  border-radius:4px;
  margin-bottom:.4rem;
  font-size:.8rem;
  color:#aaa;
}
.reply-preview .reply-to {font-weight:600;color:var(--accent);margin-bottom:.2rem;}

/* Message actions (reply button) */
.msg-actions {
  position:absolute;
  top:.5rem;
  right:.5rem;
  display:none;
  gap:.3rem;
}
.msg:hover .msg-actions {display:flex;}
.msg-action-btn {
  background:rgba(0,0,0,0.6);
  border:1px solid rgba(255,255,255,0.1);
  color:#aaa;
  padding:.3rem .5rem;
  border-radius:4px;
  cursor:pointer;
  font-size:.75rem;
  transition:all .2s;
}
.msg-action-btn:hover {background:rgba(0,255,0,0.1);border-color:var(--accent);color:var(--accent);}

@keyframes enter { from{opacity:0;transform:translateY(6px)} to{opacity:1;transform:none} }

/* Input bar with reply indicator */
.input-bar {
  display:flex;
  flex-direction:column;
  gap:.5rem;
  padding:.9rem 1rem;
  border-top:1px solid var(--border);
  background:linear-gradient(180deg,#0f0f0f,#131313);
}
.reply-indicator {
  display:none;
  background:#2a2a2a;
  padding:.5rem .75rem;
  border-radius:8px;
  border-left:3px solid var(--accent);
  font-size:.85rem;
  color:#aaa;
  align-items:center;
  justify-content:space-between;
}
.reply-indicator.active {display:flex;}
.reply-indicator .cancel-reply {
  background:transparent;
  border:none;
  color:var(--danger);
  cursor:pointer;
  font-size:1.1rem;
  padding:.2rem;
}
.input-row {display:flex;gap:.6rem;align-items:center;}
.input-row input {
  flex:1;
  padding:14px 16px;
  border-radius:10px;
  border:2px solid var(--border);
  background:#1f1f1f;
  color:#fff;
  outline:none;
  font-size:1rem;
  font-family:'JetBrains Mono',monospace;
  transition:border-color .2s;
}
.input-row input:focus {border-color:var(--accent);box-shadow:0 0 0 3px rgba(0,255,0,0.1);}
.send-btn {
  background:var(--accent);
  border:none;
  padding:12px 18px;
  border-radius:10px;
  font-weight:700;
  cursor:pointer;
  transition:all .15s;
  color:#000;
  font-family:'JetBrains Mono',monospace;
}
.send-btn:hover {filter:brightness(1.1);transform:translateY(-1px);}
.send-btn:active {transform:scale(.98);}

/* Make the attach button visually match the input height */
.input-row #attachBtn {
  padding:0 12px;
  height:44px;
  min-width:44px;
  border-radius:10px;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* Image modal styling + fade animation */
/* Modal overlay uses visibility+opacity for smooth fade in/out */
#imageModal {
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.7);
  z-index:99999;
  display:flex;
  align-items:center;
  justify-content:center;
  visibility:hidden;
  opacity:0;
  pointer-events:none;
  transition:opacity .22s ease, visibility .22s ease;
}
#imageModal.active {
  visibility:visible;
  opacity:1;
  pointer-events:auto;
}
#imageModal > div {
  max-width:900px;
  width:96%;
  background:#1b1b1b;
  border-radius:10px;
  padding:1rem;
  position:relative;
  color:#ddd;
  transform:translateY(8px) scale(.995);
  transition:transform .22s ease, opacity .22s ease;
  opacity:0;
}
#imageModal.active > div { transform:translateY(0) scale(1); opacity:1; }

/* Modal action buttons look and spacing */
.action-btn { padding:.6rem .85rem; border-radius:8px; border:1px solid var(--border); background:#2a2a2a; color:#ddd; cursor:pointer; font-weight:700; }
.action-btn.danger { background: linear-gradient(180deg,#4a1a1a,#621a1a); border-color: var(--danger); color: #fff; }
.action-btn.primary { background: linear-gradient(180deg,var(--accent),#00aa00); color:#000; border-color: transparent; }
.action-btn:not(.primary):not(.danger):hover { background:#333; }

/* Spinner small */
#uploadSpinner svg { display:block; }

/* Modals (auth, profile, settings, ban) */
.modal-overlay {
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.8);
  z-index:200;
  backdrop-filter:blur(4px);
}
.modal-overlay.active {display:flex;}
.modal-content {
  background:#1c1c1c;
  padding:2rem;
  border-radius:16px;
  border:1px solid var(--border);
  max-width:500px;
  width:92%;
  max-height:85vh;
  overflow-y:auto;
  box-shadow:0 20px 60px rgba(0,0,0,0.8);
  animation:modalEnter .3s ease;
}
/* Ensure the Call Settings modal overlays the call UI */
#callSettingsModal { z-index: 12000; }
@keyframes modalEnter { from{opacity:0;transform:scale(.95)} to{opacity:1;transform:scale(1)} }
.modal-content h2 {color:var(--accent);margin:0 0 1rem;text-align:center;font-size:1.5rem;}
.modal-content .form-group {margin-bottom:1rem;}
.modal-content .form-group label {display:block;color:#aaa;margin-bottom:.5rem;font-size:.9rem;}
.modal-content .form-group input {
  width:100%;
  padding:12px 14px;
  border-radius:8px;
  border:1px solid var(--border);
  background:#222;
  color:#fff;
  outline:none;
  font-family:'JetBrains Mono',monospace;
  transition:border-color .2s;
}
.modal-content .form-group input:focus {border-color:var(--accent);box-shadow:0 0 0 3px rgba(0,255,0,0.1);}
.modal-content .btn-group {display:flex;gap:.75rem;margin-top:1.5rem;}
.modal-content .btn {
  flex:1;
  padding:12px;
  border-radius:8px;
  border:none;
  cursor:pointer;
  font-weight:600;
  font-family:'JetBrains Mono',monospace;
  transition:all .2s;
}
.modal-content .btn-primary {background:var(--accent);color:#000;}
.modal-content .btn-primary:hover {filter:brightness(1.1);}
.modal-content .btn-secondary {background:#2a2a2a;color:#fff;border:1px solid var(--border);}
.modal-content .btn-secondary:hover {background:#333;border-color:var(--accent);color:var(--accent);}
.modal-content .error-msg {color:var(--danger);font-size:.85rem;margin-top:.5rem;display:none;}
.modal-content .info-msg {color:#aaa;font-size:.85rem;margin-top:.5rem;text-align:center;}

/* Profile modal */
.profile-modal .profile-header {
  text-align:center;
  margin-bottom:1.5rem;
  padding-bottom:1rem;
  border-bottom:1px solid var(--border);
}
.profile-modal .profile-avatar {
  width:80px;
  height:80px;
  border-radius:50%;
  background:linear-gradient(135deg,var(--accent),#00aa00);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:2rem;
  color:#000;
  font-weight:700;
  margin:0 auto 1rem;
  box-shadow:0 4px 20px rgba(0,255,0,0.3);
}
.profile-modal .profile-username {font-size:1.3rem;color:#fff;font-weight:600;margin-bottom:.3rem;}
.profile-modal .profile-status {font-size:.85rem;color:var(--muted);}
.profile-modal .profile-bio {
  background:#222;
  padding:1rem;
  border-radius:8px;
  border:1px solid var(--border);
  margin-bottom:1rem;
  color:#aaa;
  font-size:.9rem;
  line-height:1.5;
  min-height:60px;
}
.profile-modal .profile-actions {display:flex;gap:.75rem;}
.profile-modal .profile-actions .btn {flex:1;}

/* Settings modal */
.settings-modal .settings-section {margin-bottom:1.5rem;padding-bottom:1.5rem;border-bottom:1px solid var(--border);}
.settings-modal .settings-section:last-child {border-bottom:none;}
.settings-modal .settings-section h3 {color:#fff;font-size:1.1rem;margin-bottom:1rem;}
.settings-modal .setting-item {display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem;}
.settings-modal .setting-item label {color:#aaa;font-size:.9rem;}
.settings-modal .toggle-switch {
  position:relative;
  width:50px;
  height:26px;
  background:#333;
  border-radius:13px;
  cursor:pointer;
  transition:background .2s;
}
.settings-modal .toggle-switch.active {background:var(--accent);}
.settings-modal .toggle-switch::after {
  content:'';
  position:absolute;
  width:20px;
  height:20px;
  border-radius:50%;
  background:#fff;
  top:3px;
  left:3px;
  transition:left .2s;
}
.settings-modal .toggle-switch.active::after {left:27px;}

/* Ban modal */
.ban-modal {
  background:#1c1c1c;
  padding:2rem;
  border-radius:16px;
  border:2px solid var(--danger);
  max-width:450px;
  text-align:center;
  box-shadow:0 20px 60px rgba(255,102,102,0.3);
}
.ban-modal h3 {color:var(--danger);margin:0 0 1rem;font-size:1.5rem;}
.ban-modal p {color:#ddd;margin:.75rem 0 1.5rem;font-size:.95rem;line-height:1.5;}
.ban-modal .btn {
  background:#333;
  color:#fff;
  border:1px solid var(--border);
  padding:12px 24px;
  border-radius:8px;
  cursor:pointer;
  font-family:'JetBrains Mono',monospace;
  font-weight:600;
}
.ban-modal .btn:hover {background:#3a3a3a;}

/* Add custom context menu styles */
.context-menu {
  position:fixed;
  background:#1c1c1c;
  border:1px solid var(--border);
  border-radius:8px;
  padding:.5rem 0;
  min-width:180px;
  box-shadow:0 10px 30px rgba(0,0,0,0.8);
  z-index:9999;
  display:none;
}
.context-menu.active {display:block;}
.context-menu-item {
  padding:.7rem 1rem;
  color:#ddd;
  cursor:pointer;
  transition:all .15s;
  display:flex;
  align-items:center;
  gap:.6rem;
  font-size:.85rem;
}
.context-menu-item:hover {
  background:rgba(0,255,0,0.1);
  color:var(--accent);
}
.context-menu-item.danger {color:var(--danger);}
.context-menu-item.danger:hover {background:rgba(255,102,102,0.1);}

/* Add admin notification popup styles */
.admin-notification {
  position:fixed;
  top:80px;
  right:20px;
  background:#1c1c1c;
  border:2px solid var(--danger);
  border-radius:12px;
  padding:1rem 1.25rem;
  min-width:300px;
  max-width:400px;
  box-shadow:0 10px 40px rgba(255,102,102,0.4);
  z-index:9999;
  animation:slideIn .3s ease;
  display:none;
}
.admin-notification.active {display:block;}
.admin-notification .notif-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:.75rem;
}
.admin-notification .notif-title {
  color:var(--danger);
  font-weight:700;
  font-size:1rem;
  display:flex;
  align-items:center;
  gap:.5rem;
}
.admin-notification .notif-close {
  background:transparent;
  border:none;
  color:#888;
  cursor:pointer;
  font-size:1.3rem;
  padding:0;
  transition:color .2s;
}
.admin-notification .notif-close:hover {color:var(--danger);}
.admin-notification .notif-body {
  color:#ddd;
  font-size:.85rem;
  line-height:1.4;
}
.admin-notification .notif-meta {
  color:#888;
  font-size:.75rem;
  margin-top:.5rem;
  padding-top:.5rem;
  border-top:1px solid var(--border);
}
@keyframes slideIn {
  from {transform:translateX(400px);opacity:0;}
  to {transform:translateX(0);opacity:1;}
}

/* Add chat shutdown modal styles */
.shutdown-modal {
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.9);
  z-index:9999;
  backdrop-filter:blur(8px);
}
.shutdown-modal.active {display:flex;}
.shutdown-content {
  background:#1c1c1c;
  padding:2.5rem;
  border-radius:16px;
  border:2px solid var(--danger);
  max-width:500px;
  width:92%;
  text-align:center;
  box-shadow:0 20px 60px rgba(255,102,102,0.4);
  animation:modalEnter .3s ease;
}
.shutdown-icon {
  font-size:4rem;
  color:var(--danger);
  margin-bottom:1rem;
}
.shutdown-content h2 {
  color:var(--danger);
  font-size:1.8rem;
  margin-bottom:1rem;
}
.shutdown-content p {
  color:#aaa;
  font-size:1rem;
  line-height:1.6;
  margin-bottom:1.5rem;
}

/* Responsive */
@media (max-width:900px){
  .layout {flex-direction:column;}
  .users-panel {
    order:2;
    height:140px;
    display:flex;
    flex-direction:row;
    gap:.5rem;
    overflow-x:auto;
    width:100%;
    border-right:none;
    border-top:1px solid var(--border);
  }
  .users-panel .user-row {min-width:140px;flex-direction:column;align-items:flex-start;}
  .chat-card {height:calc(100vh - 210px);}
  .room-tabs {padding:.5rem .75rem;}
  .room-tab {padding:.4rem .8rem;font-size:.8rem;}
}

/* Call UI */
.call-overlay {
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.8);
  z-index:400;
  backdrop-filter:blur(6px);
}
.call-overlay.active {display:flex;}
.call-card {
  width:96%;
  max-width:980px;
  background:#1b1b1b;
  border:1px solid var(--border);
  border-radius:16px;
  padding:1.25rem 1.25rem 1rem;
  box-shadow:0 20px 60px rgba(0,0,0,0.8);
  text-align:center;
}
.call-avatar {
  width:96px;height:96px;border-radius:50%;
  margin:0 auto .9rem;
  display:flex;align-items:center;justify-content:center;
  background:linear-gradient(135deg,var(--accent),#0a0);
  color:#000;font-weight:800;font-size:2rem;
}
.call-name {color:#fff;font-weight:700;margin-bottom:.25rem;}
.call-status {color:var(--muted);font-size:.9rem;margin-bottom:1rem;}
.call-controls {display:flex;gap:.6rem;justify-content:center;}
.call-controls .btn {
  min-width:46px;min-height:42px;padding:.6rem .9rem;border-radius:10px;border:1px solid var(--border);
  background:#2a2a2a;color:#ddd;cursor:pointer;transition:all .2s;display:flex;align-items:center;gap:.4rem;
}
.call-controls .btn:hover {background:#333;border-color:var(--accent);color:var(--accent);}
/* compact controls: hide text labels to avoid squish; rely on tooltips */
.call-controls .btn .lbl { display:none; }
.btn-danger {background:#3a1f1f;border-color:#552222;color:#ff9a9a;}
.btn-danger:hover {background:#4a2323;border-color:#ff6666;color:#ff6666;}

/* Minimized call widget */
.call-widget {
  position:fixed;
  background:#1c1c1c;border:1px solid var(--border);border-radius:12px;
  padding:.6rem .75rem;min-width:220px;display:none;align-items:center;justify-content:space-between;z-index:410;
  box-shadow:0 10px 30px rgba(0,0,0,0.6);
  transition: top .2s ease, left .2s ease, right .2s ease, bottom .2s ease;
  cursor:grab;
  top:auto;left:auto;right:auto;bottom:auto;
}
.call-widget.active {display:flex;}
.call-widget .title {color:#fff;font-weight:600;font-size:.9rem;}
.call-widget .meta {color:#888;font-size:.8rem;}
.call-widget .actions {display:flex;gap:.35rem;}
.hidden {display:none !important;}

/* Call devices row */
.call-devices {margin-top:.9rem; display:flex; gap:.5rem; justify-content:center; align-items:center; flex-wrap:wrap; color:#aaa; font-size:.85rem;}
.call-devices label {opacity:.8; margin:0 .15rem;}
.call-devices select {background:#2a2a2a; border:1px solid var(--border); color:#ddd; border-radius:8px; padding:.35rem .6rem; font-family:'JetBrains Mono', monospace;}
/* Video stage: responsive 1-up / 2-up grid */
.video-stage { 
  position:relative; width:100%; margin:.75rem auto 0; max-width:1100px;
  background:#0e0e0e; border:1px solid var(--border); border-radius:10px; overflow:hidden;
  display:grid; grid-template-columns:1fr; gap:8px; padding:8px;
}
.video-stage.two-up { grid-template-columns:1fr 1fr; }
.video-stage video { width:100%; height:auto; aspect-ratio:16/9; object-fit:cover; background:#000; border-radius:8px; }
/* legacy local overlay disabled by default in new grid layout */
.video-stage .local-preview { position:static; width:100%; right:auto; bottom:auto; border:none; box-shadow:none; }
.video-settings { margin-top:.6rem; display:flex; gap:.5rem; justify-content:center; align-items:center; flex-wrap:wrap; color:#aaa; font-size:.85rem; }
.video-settings label {opacity:.8; margin:0 .15rem;}
.video-settings select, .video-settings input {background:#2a2a2a; border:1px solid var(--border); color:#ddd; border-radius:8px; padding:.35rem .6rem; font-family:'JetBrains Mono', monospace;}
  </style>
</head>
<body>
  <!-- Enhanced navbar with settings -->
  <nav class="navbar">
    <div class="logo-nav">
      <img src="../logo.png" alt="logo">
      <span>polar's.shack</span>
    </div>
    <div class="nav-links">
      <a href="index.html">home</a>
      <a href="chat.html" class="active">chat</a>
      <button id="settingsBtn" class="nav-btn"><i class='bx bx-cog'></i> settings</button>
      <button id="logoutBtn" class="nav-btn"><i class='bx bx-log-out'></i> logout</button>
    </div>
  </nav>

  <div class="layout">
    <!-- Users panel with click to view profile -->
    <aside class="users-panel">
      <h3>online users</h3>
      <div id="usersList"></div>
    </aside>

    <section class="chat-card">
      <!-- Room tabs for public + DMs -->
      <div class="room-tabs" id="roomTabs">
        <div class="room-tab active" data-room="public">
          <i class='bx bx-globe'></i> public chat
        </div>
      </div>

      <div class="chat-header">
        <div class="title" id="chatTitle">public chat</div>
        <div class="right">
          <span id="meDisplay">@guest</span>
          <button id="startCallBtn" class="icon-btn hidden" title="Start call"><i class='bx bx-phone'></i></button>
        </div>
      </div>

      <div id="messages" class="messages"></div>

      <!-- Input bar with reply indicator -->
      <div class="input-bar">
        <div class="reply-indicator" id="replyIndicator">
          <span id="replyText">replying to...</span>
          <button class="cancel-reply" id="cancelReply"><i class='bx bx-x'></i></button>
        </div>
        <div id="attachedImages" style="display:flex;gap:.5rem;margin-bottom:.5rem;"></div>
        <div class="input-row" style="position:relative">
          <button class="icon-btn" id="attachBtn" title="Attach" style="margin-right:.5rem"><i class='bx bx-paperclip'></i></button>
          <!-- small attach dropdown -->
          <div id="attachDropdown" style="display:none;position:absolute;left:0;bottom:48px;background:#1b1b1b;border:1px solid var(--border);border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.4);z-index:2000;min-width:180px;overflow:hidden">
            <button type="button" data-action="upload" style="display:flex;gap:.5rem;align-items:center;width:100%;padding:.6rem .8rem;background:transparent;border:none;color:#ddd;cursor:pointer"><i class='bx bx-upload'></i> Upload image</button>
            <button type="button" data-action="giphy" style="display:flex;gap:.5rem;align-items:center;width:100%;padding:.6rem .8rem;background:transparent;border:none;color:#ddd;cursor:pointer"><i class='bx bx-gif'></i> Search Giphy</button>
            <button type="button" data-action="poll" style="display:flex;gap:.5rem;align-items:center;width:100%;padding:.6rem .8rem;background:transparent;border:none;color:#ddd;cursor:pointer"><i class='bx bx-bar-chart-alt-2'></i> Create poll</button>
          </div>
          <input type="file" id="imageInput" accept="image/*" style="display:none" />
          <input id="messageInput" placeholder="Say something — press Enter to send" autocomplete="off" />
          <button class="send-btn" id="sendBtn">send</button>
          <div id="uploadSpinner" style="display:none;margin-left:.5rem;align-self:center" aria-hidden="true">
            <svg width="20" height="20" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
              <circle cx="25" cy="25" r="20" stroke="rgba(255,255,255,0.12)" stroke-width="6" fill="none"/>
              <path d="M45 25a20 20 0 0 1-20 20" stroke="var(--accent)" stroke-width="6" stroke-linecap="round" fill="none">
                <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite" />
              </path>
            </svg>
          </div>
        </div>

        <!-- Full image modal for preview/caption/send -->
        <div id="imageModal">
          <div style="max-width:900px;width:100%;background:#1b1b1b;border-radius:10px;padding:1rem;position:relative;color:#ddd">
              <button id="imageModalClose" type="button" style="position:absolute;top:10px;right:10px;background:transparent;border:none;color:#fff;font-size:1.25rem;cursor:pointer">✕</button>
            <div style="display:flex;gap:1rem;align-items:flex-start;">
              <img id="imageModalImg" src="" alt="preview" style="max-width:60%;border-radius:8px;display:block" />
              <div style="flex:1;display:flex;flex-direction:column;gap:.5rem">
                <textarea id="imageModalCaption" placeholder="Add a caption (optional)" style="width:100%;height:120px;padding:.6rem;border-radius:8px;border:1px solid #333;background:#121212;color:#ddd"></textarea>
                <div style="margin-top:auto;display:flex;gap:.5rem;justify-content:flex-end">
                    <button id="imageModalRemove" type="button" class="action-btn danger">Remove</button>
                    <button id="imageModalSend" type="button" class="action-btn primary">Save & Send</button>
                    <button id="imageModalCancel" type="button" class="action-btn">Close</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- GIF search modal -->
        <div id="gifModal" class="modal-overlay">
          <div class="modal-content" style="max-width:760px;display:flex;flex-direction:column;gap:.75rem;">
            <h2>search giphy</h2>
            <div class="form-group" style="margin:0">
              <input id="gifSearchInput" placeholder="search gifs" />
            </div>
            <div id="gifResults" style="height:420px;overflow-y:auto;overflow-x:hidden;column-count:3;column-gap:8px;border:1px solid var(--border);border-radius:8px;padding:8px;background:#111"></div>
            <div class="btn-group" style="margin-top:.5rem;justify-content:flex-end"><button id="gifCloseBtn" class="btn btn-secondary">close</button></div>
          </div>
        </div>

        <!-- Poll create modal -->
        <div id="pollModal" class="modal-overlay">
          <div class="modal-content" style="max-width:560px;display:flex;flex-direction:column;gap:.75rem;">
            <h2>create poll</h2>
            <div class="form-group">
              <label for="pollQuestion">question</label>
              <input id="pollQuestion" placeholder="what do you want to ask?" />
            </div>
            <div id="pollOptionsWrap" class="form-group">
              <label>options</label>
              <div id="pollOptions"></div>
              <button id="addPollOption" class="btn" type="button" style="margin-top:.5rem;width:fit-content"><i class='bx bx-plus'></i> add option</button>
            </div>
            <div class="btn-group" style="justify-content:flex-end">
              <button id="pollCancelBtn" class="btn btn-secondary" type="button">cancel</button>
              <button id="createPollBtn" class="btn btn-primary" type="button">create poll</button>
            </div>
            <p id="pollError" class="error-msg"></p>
          </div>
        </div>
       <div id="sendHint" style="font-size:.8rem;color:#888;margin-top:.25rem;"></div>
      </div>
    </section>
  </div>

  <!-- Auth modal with email verification -->
  <div id="authModal" class="modal-overlay active">
    <div class="modal-content">
      <h2>sign in / sign up</h2>
      <div id="signInForm">
        <div class="form-group">
          <label for="signInUsername">username</label>
          <input id="signInUsername" placeholder="your username" />
        </div>
        <div class="form-group">
          <label for="signInPassword">password</label>
          <input id="signInPassword" type="password" placeholder="your password" />
        </div>
        <div class="btn-group">
          <button id="signInBtn" class="btn btn-primary">sign in</button>
          <button id="showSignUpBtn" class="btn btn-secondary">need an account?</button>
        </div>
        <p id="signInError" class="error-msg"></p>
      </div>

      <div id="signUpForm" style="display:none;">
        <div class="form-group">
          <label for="authEmail">email</label>
          <input id="authEmail" type="email" placeholder="your@email.com" />
        </div>
        <div class="form-group">
          <label for="authUsername">username</label>
          <input id="authUsername" placeholder="choose a unique username" />
        </div>
        <div class="form-group">
          <label for="authPassword">password</label>
          <input id="authPassword" type="password" placeholder="secure password" />
        </div>
        <div class="btn-group">
          <button id="signUpBtn" class="btn btn-primary">sign up</button>
          <button id="showSignInBtn" class="btn btn-secondary">have an account?</button>
        </div>
        <p class="info-msg">email verification required for new accounts</p>
        <p id="authError" class="error-msg"></p>
      </div>
    </div>
  </div>

  <!-- Profile modal -->
  <div id="profileModal" class="modal-overlay">
    <div class="modal-content profile-modal">
      <div class="profile-header">
        <div class="profile-avatar" id="profileAvatar">U</div>
        <div class="profile-username" id="profileUsername">username</div>
        <div class="profile-status" id="profileStatus">online</div>
      </div>
      <div class="profile-bio" id="profileBio">no bio set</div>
      <div class="profile-actions">
        <button class="btn btn-primary" id="dmUserBtn"><i class='bx bx-message'></i> send DM</button>
        <button class="btn btn-secondary" id="closeProfileBtn">close</button>
      </div>
    </div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal" class="modal-overlay">
    <div class="modal-content settings-modal">
      <h2>settings</h2>
      
      <div class="settings-section">
        <h3>account</h3>
        <div class="form-group">
          <label for="newUsername">change username</label>
          <input id="newUsername" placeholder="new username" />
        </div>
        <button class="btn btn-primary" id="updateUsernameBtn">update username</button>
      </div>

      <div class="settings-section">
        <h3>profile</h3>
        <div class="form-group">
          <label for="userBio">bio</label>
          <input id="userBio" placeholder="tell others about yourself" maxlength="150" />
        </div>
        <button class="btn btn-primary" id="updateBioBtn">update bio</button>
      </div>

      <div class="settings-section">
        <h3>notifications</h3>
        <div class="setting-item">
          <label>sound notifications</label>
          <div class="toggle-switch" id="soundToggle"></div>
        </div>
        <div class="setting-item">
          <label>desktop notifications</label>
          <div class="toggle-switch" id="desktopToggle"></div>
        </div>
      </div>

      <div class="settings-section">
        <h3>privacy</h3>
        <div class="setting-item">
          <label>show online status</label>
          <div class="toggle-switch active" id="onlineToggle"></div>
        </div>
      </div>

      <button class="btn btn-secondary" id="closeSettingsBtn">close</button>
      <p id="settingsError" class="error-msg"></p>
    </div>
  </div>

  <!-- Ban modal -->
  <div id="banModal" class="modal-overlay">
    <div class="ban-modal">
      <h3>account banned</h3>
      <p id="banReason">you have been banned from chat for violating community guidelines.</p>
      <button class="btn" id="closeBanBtn">ok</button>
    </div>
  </div>

  <!-- Add custom context menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" id="ctxReply">
      <i class='bx bx-reply'></i> reply to message
    </div>
    <div class="context-menu-item" id="ctxCopy">
      <i class='bx bx-copy'></i> copy text
    </div>
    <div class="context-menu-item danger" id="ctxDelete">
      <i class='bx bx-trash'></i> delete message
    </div>
    <div class="context-menu-item danger" id="ctxReport">
      <i class='bx bx-flag'></i> report message
    </div>
  </div>

  <!-- Add admin notification popup -->
  <div class="admin-notification" id="adminNotification">
    <div class="notif-header">
      <div class="notif-title">
        <i class='bx bx-error-circle'></i> message reported
      </div>
      <button class="notif-close" onclick="closeAdminNotif()"><i class='bx bx-x'></i></button>
    </div>
    <div class="notif-body" id="notifBody"></div>
    <div class="notif-meta" id="notifMeta"></div>
  </div>

  <!-- Add chat shutdown modal -->
  <div class="shutdown-modal" id="shutdownModal">
    <div class="shutdown-content">
      <div class="shutdown-icon"><i class='bx bx-error-circle'></i></div>
      <h2>chat shutdown</h2>
      <p>the chat has been temporarily shut down by an administrator. please check back later.</p>
    </div>
  </div>

  <!-- Call overlay -->
  <div class="call-overlay" id="callOverlay">
    <div class="call-card">
      <div class="call-avatar" id="callAvatar">U</div>
      <div class="call-name" id="callName">username</div>
      <div class="call-status" id="callStatus">calling…</div>
      <div class="video-stage hidden" id="videoStage">
        <video id="remoteVideo" autoplay playsinline></video>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
      <div class="call-controls">
        <button class="btn" id="toggleMicBtn"><i class='bx bx-microphone'></i><span class="lbl">mic</span></button>
        <button class="btn" id="toggleVideoBtn" title="Toggle camera"><i class='bx bx-video'></i><span class="lbl">video</span></button>
        <button class="btn" id="shareScreenBtn" title="Share your screen"><i class='bx bx-desktop'></i><span class="lbl">share</span></button>
        <button class="btn" id="callSettingsBtn" title="Call settings"><i class='bx bx-slider-alt'></i><span class="lbl">settings</span></button>
        <button class="btn" id="minimizeCallBtn"><i class='bx bx-message'></i><span class="lbl">chat</span></button>
        <button class="btn btn-danger" id="hangupBtn"><i class='bx bx-phone-off'></i><span class="lbl">hang up</span></button>
      </div>
    </div>
  </div>

  <!-- Minimized call widget -->
  <div class="call-widget" id="callWidget">
    <div>
      <div class="title" id="widgetName">username</div>
      <div class="meta" id="widgetTimer">00:00</div>
    </div>
    <div class="actions">
      <button class="icon-btn" id="restoreCallBtn" title="Back to call"><i class='bx bx-expand-alt'></i></button>
      <button class="icon-btn" id="widgetHangupBtn" title="Hang up"><i class='bx bx-phone-off'></i></button>
    </div>
  </div>

  <!-- Remote audio output (hidden) -->
  <audio id="remoteAudio" autoplay playsinline class="hidden"></audio>

  <!-- Incoming call modal -->
  <div class="modal-overlay" id="incomingCallModal">
    <div class="modal-content" style="max-width:420px;text-align:center;">
      <h2>incoming call</h2>
      <div class="profile-avatar" id="incomingAvatar">U</div>
      <div class="profile-username" id="incomingName">user</div>
      <p class="info-msg">someone is calling you. answer?</p>
      <div class="btn-group">
        <button id="acceptCallBtn" class="btn btn-primary"><i class='bx bx-phone'></i> accept</button>
        <button id="declineCallBtn" class="btn btn-secondary"><i class='bx bx-phone-off'></i> decline</button>
      </div>
    </div>
  </div>

  <!-- Call Settings modal -->
  <div class="modal-overlay" id="callSettingsModal">
    <div class="modal-content" style="max-width:640px;">
      <h2>call settings</h2>

      <div class="settings-section">
        <h3>audio input</h3>
        <div class="form-group">
          <label for="micSelect">microphone</label>
          <select id="micSelect"></select>
        </div>
      </div>

      <div class="settings-section">
        <h3>audio output</h3>
        <div class="form-group">
          <label for="spkSelect">speaker/output</label>
          <select id="spkSelect"></select>
        </div>
      </div>

      <div class="settings-section">
        <h3>camera</h3>
        <div class="form-group">
          <label for="camSelect">camera device</label>
          <select id="camSelect"></select>
        </div>
      </div>

      <div class="settings-section">
        <h3>video quality</h3>
        <div class="form-group">
          <label for="videoResSelect">resolution</label>
          <select id="videoResSelect">
            <option value="1080">1080p</option>
            <option value="720">720p</option>
          </select>
        </div>
        <div class="form-group">
          <label for="videoFpsSelect">frame rate</label>
          <select id="videoFpsSelect">
            <option value="60">60</option>
            <option value="30">30</option>
          </select>
        </div>
        <div class="form-group">
          <label for="videoBitrate">bitrate (kbps)</label>
          <input id="videoBitrate" type="number" min="300" max="12000" step="100" />
        </div>
      </div>

      <div class="settings-section">
        <h3>screen share</h3>
        <div class="form-group">
          <label for="screenResSelect">resolution</label>
          <select id="screenResSelect">
            <option value="1080">1080p</option>
            <option value="720">720p</option>
          </select>
        </div>
        <div class="form-group">
          <label for="screenFpsSelect">frame rate</label>
          <select id="screenFpsSelect">
            <option value="60">60</option>
            <option value="30">30</option>
          </select>
        </div>
      </div>

      <button class="btn btn-secondary" id="closeCallSettingsBtn">close</button>
    </div>
  </div>

  <script>
    const firebaseConfig = {
      apiKey: window.__ENV?.FIREBASE_API_KEY,
      authDomain: window.__ENV?.FIREBASE_AUTH_DOMAIN,
      projectId: window.__ENV?.FIREBASE_PROJECT_ID,
      storageBucket: window.__ENV?.FIREBASE_STORAGE_BUCKET,
      messagingSenderId: window.__ENV?.FIREBASE_MESSAGING_SENDER_ID,
      appId: window.__ENV?.FIREBASE_APP_ID,
      databaseURL: window.__ENV?.FIREBASE_DATABASE_URL
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const rtdb = firebase.database();
  // keep users signed in across sessions
  auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(()=>{});

    const offensiveWords = ['badword1', 'badword2', 'offensive', 'inappropriate'];
    function containsOffensive(text) {
      const lower = text.toLowerCase();
      return offensiveWords.some(word => lower.includes(word));
    }

    const settings = {
  chatShutdown: false,
  lockdown: false,
  slowMode: 0,               // seconds
  lastSentAt: 0,             // per-session cache
};

    // paste your block RIGHT HERE:
function renderSendHint(){
  const el = document.getElementById('sendHint');
  if (!el) return;
  if (settings.chatShutdown) el.textContent = 'Chat is shut down by an admin.';
  else if (settings.lockdown) el.textContent = 'Lockdown is active. Only admins can send messages.';
  else if (settings.slowMode > 0) el.textContent = `Slow mode: ${settings.slowMode}s`;
  else el.textContent = '';
}
['chatShutdown','lockdown','slowMode'].forEach(k=>{
  Object.defineProperty(settings, k, {
    set(v){ this['_' + k] = v; renderSendHint(); },
    get(){ return this['_' + k]; }
  });
});
renderSendHint();

function nowMs(){ return Date.now(); }
function secondsLeft(endMs){ return Math.max(0, Math.ceil((endMs - nowMs())/1000)); }

    let lastMessage = '';
    let lastMessageTime = 0;

    let replyingTo = null;

    let contextMenuTarget = null;

    let currentUser = null;
    let currentRoom = 'public';
    let unsubscribeMessages = null;
    let dmRooms = [];
    let unreadDMs = {};

// Firestore-backed chat settings (admin-controlled)
const settingsDoc = db.collection('settings').doc('chat');
let unsubscribeSettings = null;
unsubscribeSettings = settingsDoc.onSnapshot(snap => {
  const data = snap.exists ? snap.data() : {};
  settings.lockdown = !!data.lockdown;
  const v = data.slowMode;
  settings.slowMode = typeof v === 'number' && v > 0 ? v : 0;
  settings.chatShutdown = !!data.chatShutdown;

  const modal = document.getElementById('shutdownModal');
  if (modal) {
    if (settings.chatShutdown) modal.classList.add('active');
    else modal.classList.remove('active');
  }
});

    document.getElementById('signUpBtn').addEventListener('click', signUp);
    document.getElementById('signInBtn').addEventListener('click', signIn);
    document.getElementById('logoutBtn').addEventListener('click', logout);
    document.getElementById('settingsBtn').addEventListener('click', () => {
      if (currentUser) {
        document.getElementById('newUsername').value = currentUser.username;
        document.getElementById('userBio').value = currentUser.bio || '';
      }
      document.getElementById('settingsModal').classList.add('active');
    });
    document.getElementById('closeSettingsBtn').addEventListener('click', () => {
      document.getElementById('settingsModal').classList.remove('active');
    });
    document.getElementById('closeProfileBtn').addEventListener('click', () => {
      document.getElementById('profileModal').classList.remove('active');
    });
    document.getElementById('closeBanBtn').addEventListener('click', () => {
      document.getElementById('banModal').classList.remove('active');
    });

    document.getElementById('updateUsernameBtn').addEventListener('click', async () => {
      const newUsername = document.getElementById('newUsername').value.trim();
      
      if (!newUsername) {
        document.getElementById('settingsError').textContent = 'Username cannot be empty';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      if (/\s/.test(newUsername)) {
        document.getElementById('settingsError').textContent = 'Usernames cannot contain spaces';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      if (containsOffensive(newUsername)) {
        document.getElementById('settingsError').textContent = 'Username contains inappropriate content';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      // Check if username is already taken
      const usernameQuery = await db.collection('users').where('username', '==', newUsername).get();
      if (!usernameQuery.empty && usernameQuery.docs[0].id !== currentUser.uid) {
        document.getElementById('settingsError').textContent = 'Username already taken';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      try {
        await db.collection('users').doc(currentUser.uid).update({ username: newUsername });
        currentUser.username = newUsername;
        document.getElementById('meDisplay').textContent = `@${newUsername}`;
        document.getElementById('settingsError').textContent = 'Username updated successfully!';
        document.getElementById('settingsError').style.color = '#00ff00';
        document.getElementById('settingsError').style.display = 'block';
        setTimeout(() => {
          document.getElementById('settingsError').style.display = 'none';
          document.getElementById('settingsError').style.color = '#ff6666';
        }, 3000);
      } catch (error) {
        document.getElementById('settingsError').textContent = 'Failed to update username';
        document.getElementById('settingsError').style.display = 'block';
      }
    });

    document.getElementById('updateBioBtn').addEventListener('click', async () => {
      const newBio = document.getElementById('userBio').value.trim();

      if (containsOffensive(newBio)) {
        document.getElementById('settingsError').textContent = 'Bio contains inappropriate content';
        document.getElementById('settingsError').style.display = 'block';
        return;
      }

      try {
        await db.collection('users').doc(currentUser.uid).update({ bio: newBio });
        currentUser.bio = newBio;
        document.getElementById('settingsError').textContent = 'Bio updated successfully!';
        document.getElementById('settingsError').style.color = '#00ff00';
        document.getElementById('settingsError').style.display = 'block';
        setTimeout(() => {
          document.getElementById('settingsError').style.display = 'none';
          document.getElementById('settingsError').style.color = '#ff6666';
        }, 3000);
      } catch (error) {
        document.getElementById('settingsError').textContent = 'Failed to update bio';
        document.getElementById('settingsError').style.display = 'block';
      }
    });

    document.getElementById('soundToggle').addEventListener('click', function() {
      this.classList.toggle('active');
      const enabled = this.classList.contains('active');
      localStorage.setItem('soundNotifications', enabled);
    });

    document.getElementById('desktopToggle').addEventListener('click', function() {
      this.classList.toggle('active');
      const enabled = this.classList.contains('active');
      localStorage.setItem('desktopNotifications', enabled);
      if (enabled && 'Notification' in window) {
        Notification.requestPermission();
      }
    });

    document.getElementById('onlineToggle').addEventListener('click', async function() {
      this.classList.toggle('active');
      const enabled = this.classList.contains('active');
      if (currentUser) {
        await db.collection('users').doc(currentUser.uid).update({ showOnlineStatus: enabled });
      }
    });

    document.getElementById('dmUserBtn').addEventListener('click', async () => {
      const profileUsername = document.getElementById('profileUsername').textContent;
      
      // Find the user by username
      const userQuery = await db.collection('users').where('username', '==', profileUsername).get();
      if (userQuery.empty) return;
      
      const targetUser = { uid: userQuery.docs[0].id, ...userQuery.docs[0].data() };
      
      // Create DM room ID (sorted UIDs to ensure consistency)
      const roomId = [currentUser.uid, targetUser.uid].sort().join('_');
      
      // Check if DM room already exists
      if (!dmRooms.find(room => room.id === roomId)) {
        dmRooms.push({
          id: roomId,
          name: `@${targetUser.username}`,
          type: 'dm',
          participants: [currentUser.uid, targetUser.uid]
        });
        
        // Save DM room to user's account
        await db.collection('users').doc(currentUser.uid).update({
          dmRooms: firebase.firestore.FieldValue.arrayUnion({
            roomId,
            withUser: targetUser.uid,
            withUsername: targetUser.username
          })
        });
        
        renderRoomTabs();
        // dm list changed, refresh watchers without losing last ids
        initDmNotificationWatchers();
        initGlobalCallWatchers();
      }
      
      // Switch to DM room
      switchRoom(roomId);
      document.getElementById('profileModal').classList.remove('active');
    });

    document.getElementById('cancelReply').addEventListener('click', () => {
      replyingTo = null;
      document.getElementById('replyIndicator').classList.remove('active');
    });

    const contextMenu = document.getElementById('contextMenu');
    document.addEventListener('contextmenu', (e) => {
      const msgEl = e.target.closest('.msg');
      if (msgEl && !msgEl.classList.contains('system')) {
        e.preventDefault();
        contextMenuTarget = msgEl;
        // show/hide delete option depending on admin status
        const deleteItem = document.getElementById('ctxDelete');
        if (deleteItem) deleteItem.style.display = (currentUser && currentUser.isAdmin) ? '' : 'none';
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
        contextMenu.classList.add('active');
      }
    });

    document.addEventListener('click', () => {
      contextMenu.classList.remove('active');
    });

    document.getElementById('ctxReply').addEventListener('click', () => {
      if (contextMenuTarget) {
        const username = contextMenuTarget.querySelector('.username').textContent;
        const content = contextMenuTarget.querySelector('.content').textContent;
        replyingTo = { username, content };
        document.getElementById('replyText').textContent = `replying to ${username}`;
        document.getElementById('replyIndicator').classList.add('active');
        document.getElementById('messageInput').focus();
      }
    });

    document.getElementById('ctxCopy').addEventListener('click', () => {
      if (contextMenuTarget) {
        const content = contextMenuTarget.querySelector('.content').textContent;
        navigator.clipboard.writeText(content);
      }
    });

    document.getElementById('ctxReport').addEventListener('click', () => {
      if (contextMenuTarget) {
        const username = contextMenuTarget.querySelector('.username').textContent;
        const content = contextMenuTarget.querySelector('.content').textContent;
        const timestamp = contextMenuTarget.querySelector('.meta span:last-child').textContent;
        reportMessage(username, content, timestamp);
      }
    });

    // Delete (admin only) via context menu
    const ctxDeleteEl = document.getElementById('ctxDelete');
    if (ctxDeleteEl) {
      ctxDeleteEl.addEventListener('click', async () => {
        if (!contextMenuTarget) return;
        if (!currentUser || !currentUser.isAdmin) { alert('Only admins can delete messages.'); return; }
        const id = contextMenuTarget.dataset.msgId;
        if (!id) { alert('Message id missing. Cannot delete.'); return; }
        if (!confirm('Delete this message? This action cannot be undone.')) return;
        try {
          await db.collection('messages').doc(id).delete();
        } catch (e) {
          console.error('Delete failed', e); alert('Failed to delete message');
        } finally {
          contextMenu.classList.remove('active');
          contextMenuTarget = null;
        }
      });
    }

    async function reportMessage(username, content, timestamp) {
      const reportData = {
        reporter: currentUser.username,
        reporterUid: currentUser.uid,
        reportedUser: username,
        message: content,
        messageTime: timestamp,
        room: currentRoom,
        timestamp: Date.now(),
        status: 'pending'
      };

      try {
        // Save report to database
        await db.collection('reports').add(reportData);
        
        // Show confirmation to reporter
        alert('Message reported successfully. Admins will review it shortly.');
        
        // Notify all online admins in real-time
        const adminsSnapshot = await db.collection('users').where('isAdmin', '==', true).where('online', '==', true).get();
        
        adminsSnapshot.forEach(async (doc) => {
          const adminData = doc.data();
          // Create notification for admin
          await db.collection('notifications').add({
            recipientUid: doc.id,
            type: 'report',
            title: 'New Message Report',
            body: `User "${username}" reported by ${currentUser.username}`,
            message: content,
            timestamp: Date.now(),
            read: false
          });
        });
        
        // Show notification to admins who are currently online
        notifyOnlineAdmins(username, content, timestamp);
      } catch (error) {
        console.error('[v0] Report error:', error);
        alert('Failed to submit report. Please try again.');
      }
    }

    function notifyOnlineAdmins(reportedUser, message, timestamp) {
      // Listen for admin notifications if current user is admin
      if (currentUser && currentUser.isAdmin) {
        const notif = document.getElementById('adminNotification');
        document.getElementById('notifBody').innerHTML = `
          <strong>Reported User:</strong> ${reportedUser}<br>
          <strong>Message:</strong> "${message}"<br>
          <strong>Time:</strong> ${timestamp}
        `;
        document.getElementById('notifMeta').textContent = `Reported by: ${currentUser.username} at ${new Date().toLocaleTimeString()}`;
        notif.classList.add('active');
        
        // Auto-hide after 15 seconds
        setTimeout(() => notif.classList.remove('active'), 15000);
      }
    }

    function closeAdminNotif() {
      document.getElementById('adminNotification').classList.remove('active');
    }

    // chatShutdown modal is now handled by Firestore settings onSnapshot above

    async function signUp() {
      const email = document.getElementById('authEmail').value.trim();
      const usernameRaw = document.getElementById('authUsername').value;
      const password = document.getElementById('authPassword').value;
      const username = (usernameRaw || '').trim();
      const usernameLower = username.toLowerCase();

      // Basic validation: non-empty, no spaces
      if (!username) {
        document.getElementById('authError').textContent = 'Please choose a username';
        document.getElementById('authError').style.display = 'block';
        return;
      }
      if (/\s/.test(username)) {
        document.getElementById('authError').textContent = 'Usernames cannot contain spaces';
        document.getElementById('authError').style.display = 'block';
        return;
      }
      if (containsOffensive(username)) {
        document.getElementById('authError').textContent = 'Username contains inappropriate content';
        document.getElementById('authError').style.display = 'block';
        return;
      }

      try {
        // Pre-check: prevent auth account creation if username already taken
        const unameDoc = await db.collection('usernames').doc(usernameLower).get();
        if (unameDoc.exists) {
          document.getElementById('authError').textContent = 'That username is already taken.';
          document.getElementById('authError').style.display = 'block';
          return;
        }

        // Create auth user only after username availability check
        const userCred = await auth.createUserWithEmailAndPassword(email, password);
        const uid = userCred.user.uid;

        // Transaction: reserve username and create profile atomically, fail if username got grabbed meanwhile
        const unameRef = db.collection('usernames').doc(usernameLower);
        const userRef = db.collection('users').doc(uid);
        await db.runTransaction(async (tx) => {
          const snap = await tx.get(unameRef);
          if (snap.exists) throw new Error('username-taken');
          tx.set(unameRef, { uid, createdAt: Date.now() });
          tx.set(userRef, {
            username,
            usernameLower,
            email,
            createdAt: Date.now(),
            isAdmin: false,
            isBanned: false,
            online: true,
            bio: '',
            dmRooms: [],
            showOnlineStatus: true
          });
        });

        document.getElementById('authModal').classList.remove('active');
        document.getElementById('authError').style.display = 'none';
      } catch (error) {
        console.error('[signup] error:', error);
        // If reservation/profile write failed, try to clean up the newly created auth user
        try { if (auth.currentUser) await auth.currentUser.delete(); } catch {}
        const msg = (error && (error.code === 'permission-denied' || error.message === 'username-taken'))
          ? 'That username is taken or invalid. Please choose another.'
          : (error && error.message) || 'Failed to create your account';
        document.getElementById('authError').textContent = msg;
        document.getElementById('authError').style.display = 'block';
      }
    }

    async function signIn() {
      const username = document.getElementById('signInUsername').value.trim();
      const password = document.getElementById('signInPassword').value;

      if (!username || !password) {
        document.getElementById('signInError').textContent = 'Please enter username and password';
        document.getElementById('signInError').style.display = 'block';
        return;
      }

      try {
  // Find user by username (case-insensitive)
  const userQuery = await db.collection('users').where('usernameLower', '==', username.toLowerCase()).limit(1).get();
        
        if (userQuery.empty) {
          document.getElementById('signInError').textContent = 'Username not found';
          document.getElementById('signInError').style.display = 'block';
          return;
        }

        const userDoc = userQuery.docs[0];
        const userData = userDoc.data();
        
        // Sign in with email and password
        await auth.signInWithEmailAndPassword(userData.email, password);
        document.getElementById('authModal').classList.remove('active');
        document.getElementById('signInError').style.display = 'none';
      } catch (error) {
        console.error('[v0] Sign in error:', error);
        document.getElementById('signInError').textContent = 'Invalid username or password';
        document.getElementById('signInError').style.display = 'block';
      }
    }

    function logout() {
      auth.signOut();
    }

    let unsubMeDoc = null;
    auth.onAuthStateChanged(async (user) => {
      console.log('[v0] Auth state changed:', user ? user.uid : 'no user');
      if (user) {
        // Ensure auth modal is hidden on auto sign-in
        try { document.getElementById('authModal').classList.remove('active'); } catch {}
        const meRef = db.collection('users').doc(user.uid);
        const userDoc = await meRef.get();
        if (userDoc.exists) {
          currentUser = { uid: user.uid, ...userDoc.data() };
          console.log('[v0] Current user loaded:', currentUser);
          
          if (currentUser.isBanned) {
            document.getElementById('banModal').classList.add('active');
            document.getElementById('banReason').textContent = currentUser.banReason || 'You have been banned from chat.';
            auth.signOut();
            return;
          }

          document.getElementById('meDisplay').textContent = `@${currentUser.username}`;
          await db.collection('users').doc(user.uid).update({ online: true });
          
          if (currentUser.dmRooms && currentUser.dmRooms.length > 0) {
            dmRooms = currentUser.dmRooms.map(dm => ({
              id: dm.roomId,
              name: `@${dm.withUsername}`,
              type: 'dm',
              participants: [currentUser.uid, dm.withUser]
            }));
            renderRoomTabs();
            // start global watchers when DMs available
            initDmNotificationWatchers();
            initGlobalCallWatchers();
          }
          
          // keep my user doc live (updates isAdmin, bio, etc.)
          if (unsubMeDoc) { try { unsubMeDoc(); } catch{} }
          unsubMeDoc = meRef.onSnapshot((snap)=>{
            if (snap.exists) {
              const prevAdmin = currentUser?.isAdmin;
              currentUser = { uid: user.uid, ...snap.data() };
              document.getElementById('meDisplay').textContent = `@${currentUser.username}`;
              // If admin changed, no special action required; menus evaluate per-open
              if (prevAdmin !== currentUser.isAdmin) {
                console.log('[v0] isAdmin changed ->', currentUser.isAdmin);
              }
            }
          });

          loadMessages();
          loadOnlineUsers();
          
          // Load saved settings
          const soundEnabled = localStorage.getItem('soundNotifications') !== 'false';
          const desktopEnabled = localStorage.getItem('desktopNotifications') === 'true';
          if (soundEnabled) document.getElementById('soundToggle').classList.add('active');
          if (desktopEnabled) document.getElementById('desktopToggle').classList.add('active');
          if (currentUser.showOnlineStatus !== false) document.getElementById('onlineToggle').classList.add('active');
          
          console.log('[v0] Messages and users loaded');
        } else {
          console.error('[v0] User document does not exist');
        }
      } else {
        if (unsubMeDoc) { try { unsubMeDoc(); } catch{} unsubMeDoc = null; }
        currentUser = null;
        document.getElementById('authModal').classList.add('active');
        document.getElementById('meDisplay').textContent = '@guest';
        cleanupDmNotificationWatchers();
        cleanupGlobalCallWatchers();
      }
    });

    function switchRoom(roomId) {
      currentRoom = roomId;
      loadMessages();
      
      if (unreadDMs[roomId]) {
        delete unreadDMs[roomId];
        renderRoomTabs();
      }
      
      // Update active tab
      document.querySelectorAll('.room-tab').forEach(tab => {
        tab.classList.remove('active');
        if (tab.dataset.room === roomId) {
          tab.classList.add('active');
        }
      });
      
      // Update chat title
      const room = dmRooms.find(r => r.id === roomId);
      if (room) {
        document.getElementById('chatTitle').textContent = `DM with ${room.name}`;
        // show call button in DMs
        document.getElementById('startCallBtn').classList.remove('hidden');
        // update call target name/avatar
        const targetName = room.name.replace(/^@/, '');
        document.getElementById('callName').textContent = targetName;
        document.getElementById('widgetName').textContent = targetName;
        document.getElementById('callAvatar').textContent = targetName[0]?.toUpperCase() || 'U';
        initCallWatcherForRoom();
      } else {
        document.getElementById('chatTitle').textContent = 'public chat';
        document.getElementById('startCallBtn').classList.add('hidden');
      }
    }

    function renderRoomTabs() {
      const tabsContainer = document.getElementById('roomTabs');
      tabsContainer.innerHTML = `
        <div class="room-tab ${currentRoom === 'public' ? 'active' : ''}" data-room="public">
          <i class='bx bx-globe'></i> public chat
        </div>
      `;
      
      dmRooms.forEach(room => {
        const tab = document.createElement('div');
        tab.className = `room-tab ${currentRoom === room.id ? 'active' : ''}`;
        tab.dataset.room = room.id;
        
        const hasUnread = unreadDMs[room.id];
        const notifDot = hasUnread ? '<span style="width:8px;height:8px;background:#ff6666;border-radius:50%;display:inline-block;margin-left:4px;box-shadow:0 0 8px #ff6666;"></span>' : '';
        
        tab.innerHTML = `
          <i class='bx bx-message'></i> ${room.name}${notifDot}
          <span class="close-dm" data-room="${room.id}">×</span>
        `;
        tab.addEventListener('click', (e) => {
          if (!e.target.classList.contains('close-dm')) {
            switchRoom(room.id);
          }
        });
        
        // Close DM functionality
        tab.querySelector('.close-dm').addEventListener('click', async (e) => {
          e.stopPropagation();
          dmRooms = dmRooms.filter(r => r.id !== room.id);
          await db.collection('users').doc(currentUser.uid).update({
            dmRooms: dmRooms.map(r => ({
              roomId: r.id,
              withUser: r.participants.find(uid => uid !== currentUser.uid),
              withUsername: r.name.substring(1)
            }))
          });
          if (currentRoom === room.id) {
            switchRoom('public');
          }
          renderRoomTabs();
          // dm list changed, refresh watchers without losing last ids
          initDmNotificationWatchers();
          initGlobalCallWatchers();
        });
        
        tabsContainer.appendChild(tab);
      });
      
      // Add click handlers to public tab
      tabsContainer.querySelector('[data-room="public"]').addEventListener('click', () => {
        switchRoom('public');
      });
    }

// ===== Infinite scroll + realtime (25/page, cap 100) =====
const PAGE_SIZE = 25;
const MAX_CACHE = 100;

let messagesCache = [];           // ASC (oldest -> newest)
let knownIds = new Set();         // for dedupe across sources
let unsubscribeLatest = null;     // realtime unsub for newest tail
let unsubscribeChanges = null;    // realtime unsub for deletes/mods within visible window
let olderCursorDesc = null;       // desc cursor to fetch older pages
let latestCursorAsc = null;       // asc cursor to fetch truly-new messages
let hasMoreOlder = true;
let isLoadingOlder = false;

let autoScroll = true;            // if true, stick to bottom as new msgs come in
let nearTopPx = 60;
let nearBottomPx = 80;

// safe DOM text setter (prevents XSS)
function setText(el, text) { el.textContent = (text ?? '').toString(); }

function isNearBottom(box){
  return (box.scrollHeight - box.scrollTop - box.clientHeight) <= nearBottomPx;
}
function isNearTop(box){
  return box.scrollTop <= nearTopPx;
}

// Smoothly force scroll to bottom, accounting for images/gifs loading
function scrollToBottom() {
  const box = document.getElementById('messages');
  if (!box) return;
  // use RAF twice to allow layout to settle
  requestAnimationFrame(() => {
    box.scrollTop = box.scrollHeight;
    requestAnimationFrame(() => { box.scrollTop = box.scrollHeight; });
  });
}

// render all cached messages (ASC). If keepPos is true, preserve scroll position (used when prepending older).
function renderMessages({ keepPos = false } = {}) {
  const box = document.getElementById('messages');
  let prevH = 0;
  if (keepPos) prevH = box.scrollHeight;

  const frag = document.createDocumentFragment();
  // OPTIONAL: faster incremental render — clear and rebuild since cap ≤ 100
  box.innerHTML = '';

  for (const msg of messagesCache) {
    const ts = msg.timestamp && typeof msg.timestamp.toMillis === 'function'
      ? msg.timestamp.toMillis()
      : (typeof msg.timestamp === 'number' ? msg.timestamp : Date.now());

    const mine = currentUser && msg.uid === currentUser.uid;
    const cls = msg.type === 'system' ? 'system' : (mine ? 'me' : 'other');

  const outer = document.createElement('div');
  outer.className = `msg ${cls}`;
  // expose the firestore id on the DOM node for context-menu actions
  if (msg.id) outer.dataset.msgId = msg.id;

    if (msg.type === 'system') {
      const c = document.createElement('div');
      c.className = 'content';
      setText(c, msg.text || '');
      outer.appendChild(c);
    } else {
      const meta = document.createElement('div');
      meta.className = 'meta';

      const name = document.createElement('span');
      name.className = 'username';
      setText(name, msg.username || 'unknown');
      meta.appendChild(name);

      if (msg.isAdmin) {
        const tag = document.createElement('span');
        tag.className = 'admin-tag';
        tag.textContent = 'ADMIN';
        meta.appendChild(tag);
      }

      const time = document.createElement('span');
      time.textContent = new Date(ts).toLocaleTimeString();
      meta.appendChild(time);
      outer.appendChild(meta);

      if (msg.replyTo) {
        const rp = document.createElement('div');
        rp.className = 'reply-preview';
        const to = document.createElement('div');
        to.className = 'reply-to';
        setText(to, '@' + (msg.replyTo.username || ''));
        rp.appendChild(to);
        const rc = document.createElement('div');
        setText(rc, (msg.replyTo.content || ''));
        rp.appendChild(rc);
        outer.appendChild(rp);
      }

      const content = document.createElement('div');
      content.className = 'content';

      if (msg.type === 'poll' || msg.pollId) {
        const card = document.createElement('div');
        card.style.border='1px solid var(--border)'; card.style.borderRadius='10px'; card.style.padding='.75rem'; card.style.background='#121212'; card.style.maxWidth='520px';
        card.innerHTML = `<div style="font-weight:700;margin-bottom:.5rem;color:#fff">poll</div><div class="q" style="color:#eee;margin-bottom:.5rem"></div><div class="opts" style="display:flex;flex-direction:column;gap:.5rem"></div>`;
        content.appendChild(card);
        buildPollCard(msg.pollId, card);
      } else if (msg.type === 'gif' || msg.gifUrl) {
        const wrap = document.createElement('div');
        wrap.className = 'image-msg';
        const img = document.createElement('img');
        img.src = msg.gifUrl || msg.mediaUrl || '';
        img.alt = msg.text || 'gif';
        img.style.maxWidth = '320px'; img.style.borderRadius = '8px'; img.style.display = 'block'; img.style.cursor = 'pointer';
        // ensure we stay at bottom when media finishes loading
        img.addEventListener('load', () => {
          const box = document.getElementById('messages');
          if (!box) return;
          if (autoScroll || isNearBottom(box)) scrollToBottom();
        });
        img.addEventListener('click', ()=>{ window.open(img.src, '_blank'); });
        wrap.appendChild(img);
        if (msg.text) {
          const cap = document.createElement('div');
          cap.className = 'image-caption';
          setText(cap, msg.text || '');
          cap.style.marginTop = '.4rem'; cap.style.color = '#ddd'; cap.style.fontSize = '.95rem';
          wrap.appendChild(cap);
        }
        content.appendChild(wrap);
      } else if (msg.type === 'image' || msg.imageUrl) {
        // image message
        const wrap = document.createElement('div');
        wrap.className = 'image-msg';
        const img = document.createElement('img');
        img.src = msg.imageUrl || msg.mediaUrl || '';
        img.alt = msg.text || msg.caption || 'image';
        img.style.maxWidth = '320px'; img.style.borderRadius = '8px'; img.style.display = 'block'; img.style.cursor = 'pointer';
        // ensure we stay at bottom when media finishes loading
        img.addEventListener('load', () => {
          const box = document.getElementById('messages');
          if (!box) return;
          if (autoScroll || isNearBottom(box)) scrollToBottom();
        });
        img.addEventListener('click', ()=>{ window.open(img.src, '_blank'); });
        wrap.appendChild(img);
        if (msg.text) {
          const cap = document.createElement('div');
          cap.className = 'image-caption';
          setText(cap, msg.text || '');
          cap.style.marginTop = '.4rem'; cap.style.color = '#ddd'; cap.style.fontSize = '.95rem';
          wrap.appendChild(cap);
        }
        content.appendChild(wrap);
      } else {
        setText(content, msg.text || '');
        // add link preview if a URL is present
        maybeRenderLinkPreview(content, msg.text || '');
      }
      outer.appendChild(content);

      // DM “Seen” tag on my last message (filled by DM extras hook)
      if (currentRoom !== 'public' && mine) {
        const seen = document.createElement('div');
        seen.className = 'meta';
        seen.style.fontSize = '.7rem';
        seen.dataset.seenFor = msg.id; // used by DM extras updater
        outer.appendChild(seen);
      }

        // admin delete handled via context menu (ctxDelete) — DOM holds msg id in dataset
    }

    frag.appendChild(outer);
  }

  box.appendChild(frag);

  if (keepPos) {
    box.scrollTop = box.scrollHeight - prevH;     // anchor after prepend
  } else if (autoScroll) {
    box.scrollTop = box.scrollHeight;             // stick to bottom
  }
}

// Watch for deletes and edits inside the currently loaded window (by timestamp)
function startDeletionWatcher(){
  // Clean up prior watcher
  if (unsubscribeChanges) { try { unsubscribeChanges(); } catch {} unsubscribeChanges = null; }
  if (!messagesCache.length) return;

  // Determine the oldest timestamp currently rendered
  const first = messagesCache[0];
  const minTs = first && first.timestamp && typeof first.timestamp.toMillis === 'function'
    ? first.timestamp.toMillis()
    : (first && typeof first.timestamp === 'number' ? first.timestamp : 0);

  // Build a query that covers our current visible window and forward
  let q = db.collection('messages')
    .where('room', '==', currentRoom)
    .orderBy('timestamp', 'asc');

  if (minTs) q = q.startAt(minTs);

  unsubscribeChanges = q.onSnapshot((snap) => {
    const changes = snap.docChanges();
    if (!changes || !changes.length) return;
    let mutated = false;
    for (const ch of changes) {
      const id = ch.doc.id;
      if (ch.type === 'removed') {
        const idx = messagesCache.findIndex(m => m.id === id);
        if (idx !== -1) {
          messagesCache.splice(idx, 1);
          knownIds.delete(id);
          mutated = true;
        }
      } else if (ch.type === 'modified') {
        const idx = messagesCache.findIndex(m => m.id === id);
        if (idx !== -1) {
          messagesCache[idx] = { id, ...ch.doc.data() };
          mutated = true;
        }
      } else {
        // ignore 'added' here; additions are handled by the newest-tail listener
      }
    }
    if (mutated) {
      // keep scroll anchored if user is reading older messages
      renderMessages({ keepPos: true });
    }
  });
}

// Render a poll card: fetch details and wire voting
async function buildPollCard(pollId, card){
  const qEl = card.querySelector('.q');
  const optsEl = card.querySelector('.opts');
  optsEl.innerHTML = '<div style="color:#888">loading…</div>';
  try {
    const resp = await fetch(`${API_BASE}/v1/polls/${encodeURIComponent(pollId)}`);
    if (!resp.ok) throw new Error('poll fetch failed');
    const poll = await resp.json();
    qEl.textContent = poll.question || 'poll';
    const total = (poll.counts || []).reduce((a,b)=>a+b,0) || 0;
    optsEl.innerHTML = '';
    (poll.options || []).forEach((opt, idx)=>{
      const count = (poll.counts && poll.counts[idx]) || 0;
      const pct = total ? Math.round((count/total)*100) : 0;
      const row = document.createElement('div');
      row.style.display='flex'; row.style.flexDirection='column'; row.style.gap='.4rem';

      const barWrap = document.createElement('div');
      barWrap.style.position='relative'; barWrap.style.background='#0e0e0e';
      barWrap.style.border='1px solid var(--border)'; barWrap.style.borderRadius='12px'; barWrap.style.overflow='hidden';

      const bar = document.createElement('div');
      bar.style.width = pct+'%'; bar.style.height='38px';
      bar.style.background='linear-gradient(90deg, #34ffa8, #00ff66)';
      bar.style.transition='width .4s ease';

      const label = document.createElement('div');
      label.style.position='absolute'; label.style.left='12px'; label.style.top='50%'; label.style.transform='translateY(-50%)';
      label.style.fontWeight='700'; label.style.color='#000'; label.textContent = opt;

      const stat = document.createElement('div');
      stat.style.position='absolute'; stat.style.right='12px'; stat.style.top='50%'; stat.style.transform='translateY(-50%)';
      stat.style.color='#000'; stat.style.fontWeight='600'; stat.textContent = `${count} • ${pct}%`;

      barWrap.appendChild(bar); barWrap.appendChild(label); barWrap.appendChild(stat);

      const btnRow = document.createElement('div'); btnRow.style.display='flex'; btnRow.style.gap='.5rem';
      const voteBtn = document.createElement('button');
      voteBtn.type='button'; voteBtn.textContent='Vote';
      voteBtn.style.padding='.45rem .9rem'; voteBtn.style.borderRadius='24px'; voteBtn.style.border='1px solid var(--border)';
      voteBtn.style.background='#1e1e1e'; voteBtn.style.color='#fff'; voteBtn.style.cursor='pointer';
      voteBtn.addEventListener('mouseenter', ()=>{ voteBtn.style.borderColor='var(--accent)'; voteBtn.style.color='var(--accent)'; });
      voteBtn.addEventListener('mouseleave', ()=>{ voteBtn.style.borderColor='var(--border)'; voteBtn.style.color='#fff'; });

      voteBtn.addEventListener('click', async ()=>{
        try {
          voteBtn.disabled = true; voteBtn.textContent = 'Voting…';
          await fetch(`${API_BASE}/v1/polls/${encodeURIComponent(pollId)}/vote`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ option: idx }) });
        } catch(e){ console.error('vote failed', e); }
        finally {
          // refresh view
          await buildPollCard(pollId, card);
        }
      });
      btnRow.appendChild(voteBtn);

      row.appendChild(barWrap);
      row.appendChild(btnRow);
      optsEl.appendChild(row);
    });
    const footer = document.createElement('div');
    footer.style.display='flex'; footer.style.justifyContent='space-between'; footer.style.marginTop='.25rem'; footer.style.color='#aaa'; footer.style.fontSize='.85rem';
    footer.innerHTML = `<span>${total} vote${total===1?'':'s'}</span>${poll.closed?'<span>closed</span>':''}`;
    optsEl.appendChild(footer);
  } catch (e) {
    console.error('poll card error', e);
    optsEl.innerHTML = '<div style="color:#f66">failed to load poll</div>';
  }
  // after poll content renders/updates, keep pinned if user is at bottom
  try {
    const box = document.getElementById('messages');
    if (box && (autoScroll || isNearBottom(box))) scrollToBottom();
  } catch {}
}

// Render link preview card under text content, if URL present
async function maybeRenderLinkPreview(container, text){
  const m = (text || '').match(/https?:\/\/[^\s]+/i);
  if (!m) return;
  const url = m[0];
  try {
    const resp = await fetch(`${API_BASE}/v1/link/preview?url=${encodeURIComponent(url)}`);
    if (!resp.ok) return;
    const meta = await resp.json();
    const card = document.createElement('a');
    card.href = url; card.target = '_blank';
    card.style.display='flex'; card.style.gap='.75rem'; card.style.alignItems='center'; card.style.textDecoration='none'; card.style.marginTop='.5rem';
    card.style.border='1px solid var(--border)'; card.style.borderRadius='10px'; card.style.padding='.6rem'; card.style.background='#121212';
    if (meta.image) {
      const img = document.createElement('img');
      img.src = meta.image; img.alt = meta.title || 'preview';
      img.style.width='72px'; img.style.height='72px'; img.style.objectFit='cover'; img.style.borderRadius='8px';
      img.addEventListener('load', ()=>{
        const box = document.getElementById('messages');
        if (box && (autoScroll || isNearBottom(box))) scrollToBottom();
      });
      card.appendChild(img);
    }
    const info = document.createElement('div'); info.style.display='flex'; info.style.flexDirection='column';
    const title = document.createElement('div'); title.textContent = meta.title || (new URL(url)).hostname; title.style.color='#fff'; title.style.fontWeight='700'; title.style.marginBottom='.25rem';
    const desc = document.createElement('div'); desc.textContent = meta.description || meta.site || ''; desc.style.color='#aaa'; desc.style.fontSize='.9rem'; desc.style.maxWidth='520px';
    info.appendChild(title); info.appendChild(desc);
    card.appendChild(info);
    container.appendChild(card);
    // appended preview may increase height; keep pinned
    const box = document.getElementById('messages');
    if (box && (autoScroll || isNearBottom(box))) scrollToBottom();
  } catch(e){ console.warn('preview failed', e); }
}

// fetch older (next page up). Prepends into cache. Respects MAX_CACHE by trimming from the NEWEST end.
async function loadOlderPage() {
  if (!hasMoreOlder || isLoadingOlder) return;
  isLoadingOlder = true;

  try {
    let q = db.collection('messages')
      .where('room', '==', currentRoom)
      .orderBy('timestamp', 'desc')
      .limit(PAGE_SIZE);

    if (olderCursorDesc) q = q.startAfter(olderCursorDesc);

    const snap = await q.get();
    if (snap.empty) {
      hasMoreOlder = false;
      return;
    }

    // update desc cursor (oldest of this batch in DESC is the last doc)
    olderCursorDesc = snap.docs[snap.docs.length - 1];

    // convert to ASC, dedupe by id
    const chunkAsc = snap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .reverse()
      .filter(d => !knownIds.has(d.id));

    // prepend older
    if (chunkAsc.length) {
      chunkAsc.forEach(m => knownIds.add(m.id));
      messagesCache = [...chunkAsc, ...messagesCache];

      // hard cap (drop from the NEWEST end to preserve the user's scrolled-up view)
      if (messagesCache.length > MAX_CACHE) {
        const toRemove = messagesCache.length - MAX_CACHE;
        const removed = messagesCache.splice(messagesCache.length - toRemove, toRemove);
        removed.forEach(m => knownIds.delete(m.id));
      }

  renderMessages({ keepPos: true });
  // refresh deletion watcher to include newly prepended range
  startDeletionWatcher();
  // update DM seen markers if needed
      updateDmSeenMarkers();
    }
  } finally {
    isLoadingOlder = false;
  }
}

// attach/refresh everything for the current room
async function loadMessages() {
  // kill previous realtime
  if (unsubscribeMessages) { unsubscribeMessages(); unsubscribeMessages = null; }
  if (unsubscribeLatest) { unsubscribeLatest(); unsubscribeLatest = null; }
  if (unsubscribeChanges) { try { unsubscribeChanges(); } catch {} unsubscribeChanges = null; }

  messagesCache = [];
  knownIds = new Set();
  hasMoreOlder = true;
  olderCursorDesc = null;
  latestCursorAsc = null;

  const box = document.getElementById('messages');

  // scroll logic: up loads older, down enables auto-follow to newest
  box.onscroll = async () => {
    if (isNearTop(box)) {
      await loadOlderPage();
    }
    // if user scrolls near bottom, re-enable auto follow
    autoScroll = isNearBottom(box);
  };

  // 1) initial: newest 25
  let initQ = db.collection('messages')
    .where('room', '==', currentRoom)
    .orderBy('timestamp', 'desc')
    .limit(PAGE_SIZE);

  const initSnap = await initQ.get();

  if (initSnap.empty) {
    messagesCache = [];
    knownIds.clear();
    renderMessages(); // clears and sits at bottom
    latestCursorAsc = null;
  } else {
    olderCursorDesc = initSnap.docs[initSnap.docs.length - 1]; // oldest of DESC batch
    const newestDoc = initSnap.docs[0];                        // newest of DESC batch
    latestCursorAsc = newestDoc;

    // seed cache in ASC + dedupe set
    messagesCache = initSnap.docs.map(d => ({ id: d.id, ...d.data() })).reverse();
    messagesCache.forEach(m => knownIds.add(m.id));

    autoScroll = true;
    renderMessages();
    // begin watching for deletes/edits within the loaded window
    startDeletionWatcher();
  }

  // 2) realtime for messages newer than current newest (ASC)
  let liveQ = db.collection('messages')
    .where('room', '==', currentRoom)
    .orderBy('timestamp', 'asc');

  if (latestCursorAsc) liveQ = liveQ.startAfter(latestCursorAsc);

  unsubscribeLatest = liveQ.onSnapshot((snap) => {
    if (snap.empty) return;

    latestCursorAsc = snap.docs[snap.docs.length - 1];

    // append new items, dedupe
    const additions = snap.docs
      .map(d => ({ id: d.id, ...d.data() }))
      .filter(d => !knownIds.has(d.id));

    if (!additions.length) return;

    additions.forEach(m => knownIds.add(m.id));
    messagesCache = [...messagesCache, ...additions];

    // cap: when appending, trim from the OLDEST end
    if (messagesCache.length > MAX_CACHE) {
      const toRemove = messagesCache.length - MAX_CACHE;
      const removed = messagesCache.splice(0, toRemove);
      removed.forEach(m => knownIds.delete(m.id));
    }

    renderMessages({ keepPos: false });
    if (autoScroll) scrollToBottom();
    updateDmSeenMarkers();
  });

  // hook up DM extras for current room (typing + seen)
  initDmExtrasForRoom();
}

    // ===== DM EXTRAS: typing indicator + seen receipts (RTDB) =====
// RTDB paths used:
//   typing/{roomId}/{uid}: boolean
//   reads/{roomId}/{uid}: serverTimeMillis

let typingTimer = null;
let unsubTyping = null;
let readsInterval = null;
let dmTypingInputHandler = null;

function markDmSeenNow(){
  if (!currentUser || currentRoom === 'public') return;
  const box = document.getElementById('messages');
  // Only mark seen when you’re caught up to the bottom
  if (!box || (box.scrollHeight - box.scrollTop - box.clientHeight) > 80) return;
  const myRef = rtdb.ref(`reads/${currentRoom}/${currentUser.uid}`);
  myRef.set(firebase.database.ServerValue.TIMESTAMP);
}

function initDmReadsWatcher(){
  if (readsInterval) { clearInterval(readsInterval); readsInterval = null; }
  if (!currentUser || currentRoom === 'public') return;
  // ping “seen” while you’re at bottom and the room is focused
  readsInterval = setInterval(markDmSeenNow, 1500);
}

function updateDmSeenMarkers(){
  if (!currentUser || currentRoom === 'public') return;
  const otherUid = currentRoom.split('_').find(u => u !== currentUser.uid);
  if (!otherUid) return;
  const otherReadRef = rtdb.ref(`reads/${currentRoom}/${otherUid}`);
  otherReadRef.once('value').then(s => {
    const otherReadAt = s.val() || 0;

    // find newest message I sent
    let lastMine = null;
    for (let i = messagesCache.length - 1; i >= 0; i--){
      const m = messagesCache[i];
      if (m && m.uid === currentUser.uid && !m.type) { lastMine = m; break; }
    }
    if (!lastMine) return;

    const ts = lastMine.timestamp && typeof lastMine.timestamp.toMillis === 'function'
      ? lastMine.timestamp.toMillis()
      : (typeof lastMine.timestamp === 'number' ? lastMine.timestamp : 0);

    const tag = document.querySelector(`[data-seen-for="${lastMine.id}"]`);
    if (!tag) return;

    tag.textContent = (otherReadAt && ts && otherReadAt >= ts) ? 'Seen' : '';
  });
}

function initDmExtrasForRoom(){
  // cleanup previous listeners/timers
  if (unsubTyping) { try { unsubTyping.ref.off('value', unsubTyping.cb); } catch{} unsubTyping = null; }
  if (typingTimer) { clearTimeout(typingTimer); typingTimer = null; }
  if (readsInterval) { clearInterval(readsInterval); readsInterval = null; }

  // remove old input handler if present
  const input = document.getElementById('messageInput');
  if (dmTypingInputHandler && input) {
    input.removeEventListener('input', dmTypingInputHandler);
    dmTypingInputHandler = null;
  }

  if (!currentUser || currentRoom === 'public') {
    // clear any typing dot in header if we left a DM
    const dot = document.getElementById('typingDot');
    if (dot) dot.textContent = '';
    return;
  }

  const otherUid = currentRoom.split('_').find(u => u !== currentUser.uid);
  if (!otherUid) return;

  // --- Typing indicator ---
  const myRef = rtdb.ref(`typing/${currentRoom}/${currentUser.uid}`);
  const otherRef = rtdb.ref(`typing/${currentRoom}/${otherUid}`);

  // header “typing…” dot
  const headerRight = document.querySelector('.chat-header .right');
  let dot = document.getElementById('typingDot');
  if (!dot) {
    dot = document.createElement('span');
    dot.id = 'typingDot';
    dot.style.marginLeft = '.4rem';
    headerRight.appendChild(dot);
  }

  const typingCb = s => { dot.textContent = s.val() ? 'typing…' : ''; };
  otherRef.on('value', typingCb);
  unsubTyping = { ref: otherRef, cb: typingCb };

  if (input) {
    dmTypingInputHandler = () => {
      myRef.set(true);
      if (typingTimer) clearTimeout(typingTimer);
      typingTimer = setTimeout(() => myRef.set(false), 2000);
    };
    input.addEventListener('input', dmTypingInputHandler);
    input.addEventListener('keydown', dmTypingInputHandler);
  }

  // --- Seen receipts ---
  initDmReadsWatcher();
  markDmSeenNow();
  updateDmSeenMarkers();
}

// One-time: keep seen current when you scroll to bottom
(function initDmGlobalScrollHook(){
  const box = document.getElementById('messages');
  if (!box) return;
  box.addEventListener('scroll', () => {
    if (currentRoom !== 'public') {
      markDmSeenNow();
      updateDmSeenMarkers();
    }
  });
})();

// Global mutation observer: if we're near the bottom or auto-following, keep pinned when DOM mutates
(function initAutoScrollMutationObserver(){
  const box = document.getElementById('messages');
  if (!box || typeof MutationObserver === 'undefined') return;
  const obs = new MutationObserver(() => {
    if (autoScroll || isNearBottom(box)) scrollToBottom();
  });
  obs.observe(box, { childList: true, subtree: true });
})();

// ===== Calls (WebRTC audio over Firebase RTDB) =====
let pc = null;
let localStream = null;
let remoteStream = null;
let callInterval = null;
let callStartAt = null;
let isCaller = false;
let callRefs = { offer: null, answer: null, myCands: null, otherCands: null, state: null };
let currentCallRoom = null;
let incomingCallCtx = null;
let globalOfferWatchers = {};
let globalStateWatchers = {};
let dmMsgWatchers = {};
let dmMsgLastDocId = {};

// Video/screen share state
let localVideoStream = null; // camera
let screenStream = null;     // screen share
let remoteVideoStream = null;
let videoSender = null;      // RTCRtpSender for video
let isSharingScreen = false;
let makingOffer = false;     // for renegotiation
let isPolite = false;        // simple glare mitigation
let renegoRefs = { offer: null, answer: null };

let rtcConfig = { iceServers: [{ urls: [
  'stun:stun.l.google.com:19302',
  'stun:stun1.l.google.com:19302'
] }], iceTransportPolicy: 'all' };

// Optional: allow admins to inject TURN/ICE servers from RTDB at settings/iceServers
// Expected format: either an array of RTCIceServer entries or a single object
// Example array entry: { urls: ['turn:turn.example.com:3478'], username: 'user', credential: 'pass' }
try {
  rtdb.ref('settings/iceServers').on('value', s => {
    const v = s.val();
    if (!v) return;
    const baseStuns = [{ urls: ['stun:stun.l.google.com:19302','stun:stun1.l.google.com:19302'] }];
    if (Array.isArray(v)) {
      rtcConfig.iceServers = [...baseStuns, ...v];
    } else if (typeof v === 'object') {
      rtcConfig.iceServers = [...baseStuns, v];
    }
  });
  rtdb.ref('settings/iceTransportPolicy').on('value', s => {
    const v = s.val();
    if (v === 'relay' || v === 'all') rtcConfig.iceTransportPolicy = v;
  });
} catch (e) { /* ignore optional config errors */ }

function dmOtherUid(){
  if (!currentUser || currentRoom === 'public') return null;
  const parts = currentRoom.split('_');
  return parts.find(u => u !== currentUser.uid) || null;
}

function showCallOverlay(){
  document.getElementById('callOverlay').classList.add('active');
  document.getElementById('callWidget').classList.remove('active');
  try { updateVideoStageVisibility(); } catch {}
}
function hideCallOverlay(){
  document.getElementById('callOverlay').classList.remove('active');
}
function showCallWidget(){
  document.getElementById('callWidget').classList.add('active');
}
function hideCallWidget(){
  document.getElementById('callWidget').classList.remove('active');
}

function formatDuration(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const m = Math.floor(s/60); const r = s%60;
  return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
}

function startTimer(){
  const set = () => {
    const now = Date.now();
    const d = callStartAt ? now - callStartAt : 0;
    const t = formatDuration(d);
    document.getElementById('callStatus').textContent = `in call · ${t}`;
    document.getElementById('widgetTimer').textContent = t;
  };
  set();
  callInterval = setInterval(set, 1000);
}
function stopTimer(){ if (callInterval) { clearInterval(callInterval); callInterval = null; } }

async function getMic(){
  if (localStream) return localStream;
  const prefMic = localStorage.getItem('prefMicId');
  const constraints = prefMic ? { audio: { deviceId: { exact: prefMic } } } : { audio: true };
  localStream = await navigator.mediaDevices.getUserMedia(constraints);
  try { await initDeviceSelectors(); } catch {}
  return localStream;
}

function cleanupCallListeners(){
  if (callRefs.offer) { callRefs.offer.off(); callRefs.offer = null; }
  if (callRefs.answer) { callRefs.answer.off(); callRefs.answer = null; }
  if (callRefs.myCands) { callRefs.myCands.off(); callRefs.myCands = null; }
  if (callRefs.otherCands) { callRefs.otherCands.off(); callRefs.otherCands = null; }
  if (callRefs.state) { callRefs.state.off(); callRefs.state = null; }
}

async function endCall(reason='ended'){
  try {
    rtdb.ref(`calls/${currentCallRoom}/state`).set({ by: currentUser?.uid || 'sys', state: reason, at: firebase.database.ServerValue.TIMESTAMP });
  } catch {}
  stopRingtone();
  stopTimer();
  hideCallOverlay();
  hideCallWidget();
  if (pc) { try { pc.getSenders().forEach(s=>s.track&&s.track.stop()); pc.close(); } catch{} pc=null; }
  if (localStream) { try { localStream.getTracks().forEach(t=>t.stop()); } catch{} localStream=null; }
  if (localVideoStream) { try { localVideoStream.getTracks().forEach(t=>t.stop()); } catch{} localVideoStream=null; }
  if (screenStream) { try { screenStream.getTracks().forEach(t=>t.stop()); } catch{} screenStream=null; }
  remoteStream=null;
  remoteVideoStream=null;
  videoSender=null;
  isSharingScreen=false;
  document.getElementById('remoteAudio').srcObject = null;
  const rv = document.getElementById('remoteVideo'); if (rv) rv.srcObject = null;
  const lv = document.getElementById('localVideo'); if (lv) lv.srcObject = null;
  cleanupCallListeners();
  // best-effort cleanup of signaling for this call
  if (currentCallRoom) {
    const base = rtdb.ref(`calls/${currentCallRoom}`);
    base.child('offer').remove();
    base.child('answer').remove();
    base.child('candidates').remove();
    base.child('renegotiate').remove();
  }
  currentCallRoom = null;
  isCaller = false;
  callStartAt = null;
  updateVideoStageVisibility();
}

function bindPeerEvents(){
  pc.onicecandidate = (e) => {
    if (e.candidate) {
      rtdb.ref(`calls/${currentCallRoom}/candidates/${currentUser.uid}`).push(e.candidate.toJSON());
    }
  };
  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'connected') {
      document.getElementById('callStatus').textContent = 'connected';
    }
    if (['failed','disconnected','closed'].includes(pc.connectionState)) {
      // give a brief grace period for transient disconnects before ending
      const state = pc.connectionState;
      setTimeout(() => {
        if (!pc || pc.connectionState !== state) return; // recovered
        endCall(state);
      }, 1500);
    }
  };
  pc.ontrack = (e) => {
    // Route audio tracks to hidden audio element; video tracks to remoteVideo element
    e.streams.forEach(stream => {
      stream.getTracks().forEach(t => {
        if (t.kind === 'audio') {
          if (!remoteStream) remoteStream = new MediaStream();
          remoteStream.addTrack(t);
          const audio = document.getElementById('remoteAudio');
          audio.srcObject = remoteStream;
          audio.volume = 1.0;
          const prefSpk = localStorage.getItem('prefSpkId');
          if (prefSpk && typeof audio.setSinkId === 'function') {
            audio.setSinkId(prefSpk).catch(()=>{});
          }
          audio.play && audio.play().catch(()=>{});
        } else if (t.kind === 'video') {
          if (!remoteVideoStream) remoteVideoStream = new MediaStream();
          remoteVideoStream.addTrack(t);
          const rv = document.getElementById('remoteVideo');
          rv.srcObject = remoteVideoStream;
          rv.play && rv.play().catch(()=>{});
          try {
            t.addEventListener('ended', ()=>{ try { remoteVideoStream && remoteVideoStream.removeTrack(t); } catch{}; updateVideoStageVisibility(); });
          } catch {}
        }
      });
    });
    updateVideoStageVisibility();
  };
}

function getVideoPrefs(){
  return {
    camDeviceId: localStorage.getItem('prefCamId') || undefined,
    videoRes: parseInt(localStorage.getItem('prefVideoRes')||'1080',10),
    videoFps: parseInt(localStorage.getItem('prefVideoFps')||'60',10),
    videoBitrateKbps: parseInt(localStorage.getItem('prefVideoBitrate')||'4500',10),
    screenRes: parseInt(localStorage.getItem('prefScreenRes')||'1080',10),
    screenFps: parseInt(localStorage.getItem('prefScreenFps')||'60',10)
  };
}

function initVideoSelectorsUI(){
  const prefs = getVideoPrefs();
  const vRes = document.getElementById('videoResSelect'); if (vRes) vRes.value = String(prefs.videoRes);
  const vFps = document.getElementById('videoFpsSelect'); if (vFps) vFps.value = String(prefs.videoFps);
  const vBr = document.getElementById('videoBitrate'); if (vBr) vBr.value = String(prefs.videoBitrateKbps);
  const sRes = document.getElementById('screenResSelect'); if (sRes) sRes.value = String(prefs.screenRes);
  const sFps = document.getElementById('screenFpsSelect'); if (sFps) sFps.value = String(prefs.screenFps);
}

async function getCameraStream(){
  const prefs = getVideoPrefs();
  const width = prefs.videoRes === 1080 ? 1920 : 1280;
  const height = prefs.videoRes === 1080 ? 1080 : 720;
  const fps = prefs.videoFps;
  const constraints = {
    video: {
      width: { ideal: width },
      height: { ideal: height },
      frameRate: { ideal: fps, max: fps },
      deviceId: prefs.camDeviceId ? { exact: prefs.camDeviceId } : undefined
    },
    audio: false
  };
  try {
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    return stream;
  } catch (e) {
    // fallback to default video
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    return stream;
  }
}

async function startCamera(){
  localVideoStream = await getCameraStream();
  const lv = document.getElementById('localVideo');
  lv.srcObject = localVideoStream; lv.play && lv.play().catch(()=>{});
  const track = localVideoStream.getVideoTracks()[0];
  if (!track) return;
  if (pc) {
    if (!videoSender) {
      const trans = pc.addTransceiver('video', { direction: 'sendrecv' });
      videoSender = trans.sender;
    }
    await videoSender.replaceTrack(track);
    await ensureRenegotiation();
    await applyVideoEncodingPrefs();
  }
  updateVideoStageVisibility();
}

async function stopCamera(){
  try { if (localVideoStream) localVideoStream.getTracks().forEach(t=>t.stop()); } catch{}
  localVideoStream = null;
  const lv = document.getElementById('localVideo'); lv.srcObject = null;
  if (videoSender && !isSharingScreen) {
    await videoSender.replaceTrack(null);
    await ensureRenegotiation();
  }
  updateVideoStageVisibility();
}

async function startScreenShare(){
  const prefs = getVideoPrefs();
  const width = prefs.screenRes === 1080 ? 1920 : 1280;
  const height = prefs.screenRes === 1080 ? 1080 : 720;
  const fps = prefs.screenFps;
  const constraints = { video: { frameRate: { ideal: fps, max: fps }, width: { ideal: width }, height: { ideal: height }, cursor: 'always' }, audio: false };
  try {
    screenStream = await navigator.mediaDevices.getDisplayMedia(constraints);
  } catch (e) {
    console.warn('getDisplayMedia failed', e);
    return;
  }
  isSharingScreen = true;
  const track = screenStream.getVideoTracks()[0];
  if (track) {
    const lv = document.getElementById('localVideo'); lv.srcObject = screenStream; lv.play && lv.play().catch(()=>{});
    if (!videoSender) {
      const trans = pc.addTransceiver('video', { direction: 'sendrecv' });
      videoSender = trans.sender;
    }
    await videoSender.replaceTrack(track);
    await ensureRenegotiation();
    await applyVideoEncodingPrefs(true);
  }
  // When user stops sharing via browser UI
  const onEnded = () => { stopScreenShare(); };
  track && track.addEventListener('ended', onEnded, { once:true });
  updateVideoStageVisibility();
}

async function stopScreenShare(){
  try { if (screenStream) screenStream.getTracks().forEach(t=>t.stop()); } catch{}
  screenStream = null; isSharingScreen = false;
  if (localVideoStream && videoSender) {
    await videoSender.replaceTrack(localVideoStream.getVideoTracks()[0]||null);
    await ensureRenegotiation();
    await applyVideoEncodingPrefs();
    const lv = document.getElementById('localVideo'); lv.srcObject = localVideoStream;
  } else {
    if (videoSender) { await videoSender.replaceTrack(null); await ensureRenegotiation(); }
    const lv = document.getElementById('localVideo'); lv.srcObject = null;
  }
  updateVideoStageVisibility();
}

async function applyVideoEncodingPrefs(isScreen=false){
  if (!videoSender) return;
  const params = videoSender.getParameters();
  if (!params.encodings) params.encodings = [{}];
  const prefs = getVideoPrefs();
  const kbps = Math.max(300, parseInt(prefs.videoBitrateKbps||'4500',10));
  params.encodings[0].maxBitrate = kbps * 1000;
  try { await videoSender.setParameters(params); } catch {}
  try {
    const track = (isScreen ? screenStream?.getVideoTracks()[0] : localVideoStream?.getVideoTracks()[0]);
    if (track) {
      const fps = isScreen ? getVideoPrefs().screenFps : getVideoPrefs().videoFps;
      await track.applyConstraints({ frameRate: { ideal: fps, max: fps } });
    }
  } catch {}
}

async function ensureRenegotiation(){
  if (!pc) return;
  try {
    await doNegotiation();
  } catch (e) { console.warn('renegotiation error', e); }
}

function setupRenegotiationChannel(){
  const other = dmOtherUid();
  isPolite = other && currentUser && String(currentUser.uid) > String(other);
  const base = rtdb.ref(`calls/${currentCallRoom}/renegotiate`);
  renegoRefs.offer = base.child(`inbox/${currentUser.uid}/offer`);
  renegoRefs.offer.on('value', async (s) => {
    const v = s.val();
    if (!v) return;
    try {
      if (pc.signalingState !== 'stable') {
        if (!isPolite) { return; }
      }
      await pc.setRemoteDescription(new RTCSessionDescription({ type:'offer', sdp: v.sdp }));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      const ansRef = base.child(`inbox/${v.from}/answer`);
      await ansRef.set({ sdp: answer.sdp, type: answer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
    } catch (e) { console.warn('negotiation offer error', e); }
    finally { renegoRefs.offer.set(null); }
  });
  renegoRefs.answer = base.child(`inbox/${currentUser.uid}/answer`);
  renegoRefs.answer.on('value', async (s) => {
    const v = s.val();
    if (!v) return;
    try {
      await pc.setRemoteDescription(new RTCSessionDescription({ type:'answer', sdp: v.sdp }));
    } catch (e) { console.warn('negotiation answer error', e); }
    finally { renegoRefs.answer.set(null); }
  });
}

async function doNegotiation(){
  if (!pc) return;
  const other = dmOtherUid();
  if (!other) return;
  const base = rtdb.ref(`calls/${currentCallRoom}/renegotiate`);
  const outRef = base.child(`inbox/${other}/offer`);
  try {
    makingOffer = true;
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await outRef.set({ sdp: offer.sdp, type: offer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  } catch (e) { console.warn('doNegotiation failed', e); }
  finally { makingOffer = false; }
}

async function startOutgoingCall(){
  if (!currentUser || currentRoom==='public') return alert('Open a DM to start a call.');
  if (pc) return; // already in a call
  currentCallRoom = currentRoom;
  isCaller = true;
  showCallOverlay();
  document.getElementById('callStatus').textContent = 'calling…';

  pc = new RTCPeerConnection(rtcConfig);
  bindPeerEvents();
  setupRenegotiationChannel();
  const mic = await getMic();
  mic.getTracks().forEach(t => pc.addTrack(t, mic));
  // Prepare a video transceiver for future camera/screen tracks
  const vTrans = pc.addTransceiver('video', { direction: 'sendrecv' });
  videoSender = vTrans.sender;

  const offer = await pc.createOffer({ offerToReceiveAudio: true });
  await pc.setLocalDescription(offer);

  const base = rtdb.ref(`calls/${currentCallRoom}`);
  await base.child('offer').set({ sdp: offer.sdp, type: offer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  await base.child('state').set({ state:'ringing', by: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  startRingtone();

  // listen for answer
  callRefs.answer = base.child('answer');
  callRefs.answer.on('value', async (s) => {
    const ans = s.val();
    if (ans && pc && !pc.currentRemoteDescription) {
      await pc.setRemoteDescription(new RTCSessionDescription({ type: ans.type, sdp: ans.sdp }));
      stopRingtone();
      callStartAt = Date.now();
      startTimer();
      document.getElementById('callStatus').textContent = 'connecting…';
    }
  });

  // ICE from other side
  const other = dmOtherUid();
  callRefs.otherCands = base.child(`candidates/${other}`);
  callRefs.otherCands.on('child_added', async (snap) => {
    const c = snap.val();
    try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch {}
  });

  // observe state for end
  callRefs.state = base.child('state');
  callRefs.state.on('value', (s)=>{
    const v = s.val();
    if (v && v.state==='ended') endCall('remote-ended');
  });
}

async function acceptIncomingCall(offer){
  if (pc) return; // busy
  currentCallRoom = currentRoom;
  isCaller = false;
  showCallOverlay();
  document.getElementById('callStatus').textContent = 'connecting…';
  stopRingtone();

  pc = new RTCPeerConnection(rtcConfig);
  bindPeerEvents();
  setupRenegotiationChannel();
  const mic = await getMic();
  mic.getTracks().forEach(t => pc.addTrack(t, mic));
  const vTrans = pc.addTransceiver('video', { direction: 'sendrecv' });
  videoSender = vTrans.sender;

  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  const base = rtdb.ref(`calls/${currentCallRoom}`);
  await base.child('answer').set({ sdp: answer.sdp, type: answer.type, from: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  await base.child('state').set({ state:'connected', by: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  callStartAt = Date.now();
  startTimer();

  // receive ICE from other side
  const other = dmOtherUid();
  callRefs.otherCands = base.child(`candidates/${other}`);
  callRefs.otherCands.on('child_added', async (snap) => {
    const c = snap.val();
    try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch {}
  });

  // observe state for end
  callRefs.state = base.child('state');
  callRefs.state.on('value', (s)=>{
    const v = s.val();
    if (v && v.state==='ended') endCall('remote-ended');
  });
}

// Watch for incoming offers in the active DM room
function initCallWatcherForRoom(){
  cleanupCallListeners();
  if (currentRoom==='public' || !currentUser) return;
  const base = rtdb.ref(`calls/${currentRoom}`);
  currentCallRoom = currentRoom; // used for watcher path

  if (pc) {
    // During an active call, keep watching state to detect remote hangup
    callRefs.state = base.child('state');
    callRefs.state.on('value', (s)=>{
      const v = s.val();
      if (v && v.state==='ended') { stopRingtone(); endCall('remote-ended'); }
    });
    return;
  }

  // Not in a call: watch for incoming offers
  callRefs.offer = base.child('offer');
  callRefs.offer.on('value', async (s) => {
    const v = s.val();
    if (!v || pc) return; // nothing or already busy
    if (v.from === currentUser.uid) return; // my own offer
    // incoming call UI: styled modal
    const room = dmRooms.find(r=>r.id===currentRoom);
    const callerName = room ? room.name.replace(/^@/,'') : 'user';
    document.getElementById('incomingName').textContent = callerName;
    document.getElementById('incomingAvatar').textContent = (callerName[0]||'U').toUpperCase();
    incomingCallCtx = { roomId: currentRoom, offer: { type: v.type, sdp: v.sdp } };
    document.getElementById('incomingCallModal').classList.add('active');
    startRingtone();
  });
  // watch state to stop ring if caller cancels before accept
  callRefs.state = base.child('state');
  callRefs.state.on('value', (s)=>{
    const v = s.val();
    if (v && v.state==='ended' && incomingCallCtx && incomingCallCtx.roomId === currentRoom) {
      document.getElementById('incomingCallModal').classList.remove('active');
      incomingCallCtx = null; stopRingtone();
    }
  });
}

// UI bindings
document.getElementById('startCallBtn').addEventListener('click', startOutgoingCall);
document.getElementById('hangupBtn').addEventListener('click', () => endCall('ended'));
document.getElementById('widgetHangupBtn').addEventListener('click', () => endCall('ended'));
document.getElementById('minimizeCallBtn').addEventListener('click', () => { hideCallOverlay(); showCallWidget(); });
document.getElementById('restoreCallBtn').addEventListener('click', () => { showCallOverlay(); hideCallWidget(); });
document.getElementById('toggleMicBtn').addEventListener('click', () => {
  if (!localStream) return;
  const track = localStream.getAudioTracks()[0];
  if (!track) return;
  track.enabled = !track.enabled;
  const icon = document.querySelector('#toggleMicBtn i');
  if (track.enabled) { icon.className = 'bx bx-microphone'; document.getElementById('toggleMicBtn').title = 'Mute mic'; }
  else { icon.className = 'bx bx-microphone-off'; document.getElementById('toggleMicBtn').title = 'Unmute mic'; }
});
document.getElementById('toggleVideoBtn').addEventListener('click', async () => {
  const btn = document.getElementById('toggleVideoBtn');
  const icon = btn.querySelector('i');
  if (!localVideoStream && !isSharingScreen) {
    await startCamera();
    icon.className = 'bx bx-video-off'; btn.title = 'Turn off camera';
    return;
  }
  if (isSharingScreen) {
    await stopScreenShare();
    icon.className = localVideoStream ? 'bx bx-video-off' : 'bx bx-video';
    btn.title = localVideoStream ? 'Turn off camera' : 'Turn on camera';
    return;
  }
  await stopCamera();
  icon.className = 'bx bx-video'; btn.title = 'Turn on camera';
});
document.getElementById('shareScreenBtn').addEventListener('click', async () => {
  const btn = document.getElementById('shareScreenBtn');
  const icon = btn.querySelector('i');
  if (!isSharingScreen) {
    await startScreenShare();
    if (isSharingScreen) { icon.className = 'bx bx-stop'; btn.title = 'Stop sharing'; }
  } else {
    await stopScreenShare();
    icon.className = 'bx bx-desktop'; btn.title = 'Share your screen';
  }
});
document.getElementById('callSettingsBtn').addEventListener('click', async () => {
  document.getElementById('callSettingsModal').classList.add('active');
  try { await initDeviceSelectors(); } catch {}
});
document.getElementById('closeCallSettingsBtn').addEventListener('click', () => {
  document.getElementById('callSettingsModal').classList.remove('active');
});

// Device selectors: mic and speaker
async function initDeviceSelectors(){
  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
  const devices = await navigator.mediaDevices.enumerateDevices();
  const inputs = devices.filter(d=>d.kind==='audioinput');
  const outputs = devices.filter(d=>d.kind==='audiooutput');
  const micSel = document.getElementById('micSelect');
  const spkSel = document.getElementById('spkSelect');
  if (micSel){
    const prefMic = localStorage.getItem('prefMicId');
    micSel.innerHTML = '';
    inputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId; opt.textContent = d.label || `Microphone ${micSel.length+1}`;
      if (prefMic && d.deviceId===prefMic) opt.selected = true;
      micSel.appendChild(opt);
    });
    micSel.onchange = async ()=>{
      const id = micSel.value; localStorage.setItem('prefMicId', id);
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: id } } });
        const newTrack = newStream.getAudioTracks()[0];
        if (pc) {
          const sender = pc.getSenders().find(s=>s.track && s.track.kind==='audio');
          if (sender) await sender.replaceTrack(newTrack);
        }
        if (localStream) localStream.getTracks().forEach(t=>t.stop());
        localStream = newStream;
      } catch(e) { console.warn('mic switch failed', e); }
    };
  }
  if (spkSel){
    const prefSpk = localStorage.getItem('prefSpkId');
    spkSel.innerHTML = '';
    outputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId; opt.textContent = d.label || `Speaker ${spkSel.length+1}`;
      if (prefSpk && d.deviceId===prefSpk) opt.selected = true;
      spkSel.appendChild(opt);
    });
    if (typeof document.getElementById('remoteAudio').setSinkId !== 'function') {
      // Speaker selection unsupported; hide just the label + select
      const label = spkSel.previousElementSibling;
      if (label) label.style.display = 'none';
      spkSel.style.display = 'none';
    } else {
      spkSel.onchange = async ()=>{
        const id = spkSel.value; localStorage.setItem('prefSpkId', id);
        try { await document.getElementById('remoteAudio').setSinkId(id); } catch(e){ console.warn('setSinkId failed', e);} 
      };
    }
  }
  // refresh lists when devices change
  navigator.mediaDevices.ondevicechange = async ()=>{
    try { await initDeviceSelectors(); } catch{}
  };

  // Populate camera select
  const devices2 = await navigator.mediaDevices.enumerateDevices();
  const cams = devices2.filter(d=>d.kind==='videoinput');
  const camSel = document.getElementById('camSelect');
  if (camSel){
    const prefCam = localStorage.getItem('prefCamId');
    camSel.innerHTML = '';
    cams.forEach((d, idx)=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId; opt.textContent = d.label || `Camera ${idx+1}`;
      if (prefCam && d.deviceId===prefCam) opt.selected = true;
      camSel.appendChild(opt);
    });
    camSel.onchange = async ()=>{
      const id = camSel.value; localStorage.setItem('prefCamId', id);
      if (localVideoStream) {
        try {
          const prefs = getVideoPrefs();
          const width = prefs.videoRes===1080?1920:1280; const height = prefs.videoRes===1080?1080:720; const fps = prefs.videoFps;
          const newStream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: id }, width: { ideal: width }, height: { ideal: height }, frameRate: { ideal: fps, max: fps } } });
          const newTrack = newStream.getVideoTracks()[0];
          if (videoSender) await videoSender.replaceTrack(newTrack);
          localVideoStream.getTracks().forEach(t=>t.stop());
          localVideoStream = newStream;
          document.getElementById('localVideo').srcObject = newStream;
          await ensureRenegotiation();
        } catch(e){ console.warn('camera switch failed', e); }
      }
    };
  }

  // Hook video settings to localStorage and live updates
  ['videoResSelect','videoFpsSelect','videoBitrate','screenResSelect','screenFpsSelect'].forEach(id=>{
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', ()=>{
      if (id==='videoResSelect') localStorage.setItem('prefVideoRes', el.value);
      if (id==='videoFpsSelect') localStorage.setItem('prefVideoFps', el.value);
      if (id==='videoBitrate') localStorage.setItem('prefVideoBitrate', el.value);
      if (id==='screenResSelect') localStorage.setItem('prefScreenRes', el.value);
      if (id==='screenFpsSelect') localStorage.setItem('prefScreenFps', el.value);
      if (id==='videoBitrate') applyVideoEncodingPrefs(isSharingScreen);
    });
  });
  initVideoSelectorsUI();
}

function updateVideoStageVisibility(){
  const stage = document.getElementById('videoStage');
  if (!stage) return;
  const localVideoEl = document.getElementById('localVideo');
  const remoteVideoEl = document.getElementById('remoteVideo');
  // local is active if camera stream live OR screen stream live
  const localCamOn = !!(localVideoStream && typeof localVideoStream.getVideoTracks === 'function' && localVideoStream.getVideoTracks().some(t=>t.readyState==='live'));
  const localScreenOn = !!(isSharingScreen && screenStream && typeof screenStream.getVideoTracks === 'function' && screenStream.getVideoTracks().some(t=>t.readyState==='live'));
  const localOn = localCamOn || localScreenOn || !!(localVideoEl && localVideoEl.srcObject && localVideoEl.srcObject.getVideoTracks && localVideoEl.srcObject.getVideoTracks().some(t=>t.readyState==='live'));
  const remoteOn = !!(remoteVideoStream && typeof remoteVideoStream.getVideoTracks === 'function' && remoteVideoStream.getVideoTracks().some(t=>t.readyState==='live'));

  // Toggle per-tile visibility
  if (localVideoEl) localVideoEl.classList.toggle('hidden', !localOn);
  if (remoteVideoEl) remoteVideoEl.classList.toggle('hidden', !remoteOn);

  const anyOn = localOn || remoteOn;
  stage.classList.toggle('hidden', !anyOn);
  stage.classList.toggle('two-up', localOn && remoteOn);
}

// incoming call modal buttons
document.getElementById('acceptCallBtn').addEventListener('click', async ()=>{
  const ctx = incomingCallCtx; incomingCallCtx = null;
  document.getElementById('incomingCallModal').classList.remove('active');
  if (!ctx) return;
  if (currentRoom !== ctx.roomId) switchRoom(ctx.roomId);
  await acceptIncomingCall(ctx.offer);
});
document.getElementById('declineCallBtn').addEventListener('click', async ()=>{
  const ctx = incomingCallCtx; incomingCallCtx = null;
  document.getElementById('incomingCallModal').classList.remove('active');
  if (!ctx) return;
  stopRingtone();
  const base = rtdb.ref(`calls/${ctx.roomId}`);
  await base.child('state').set({ state:'ended', by: currentUser.uid, at: firebase.database.ServerValue.TIMESTAMP });
  // missed call system message
  const other = ctx.roomId.split('_').find(u=>u!==currentUser.uid);
  const otherDoc = await db.collection('users').doc(other).get();
  const otherName = otherDoc.exists ? otherDoc.data().username : 'user';
  await db.collection('messages').add({ type:'system', text:`Missed call from @${otherName}`, room: ctx.roomId, timestamp: Date.now() });
});

// Ensure typing=false when closing the page
window.addEventListener('beforeunload', () => {
  if (!currentUser || currentRoom === 'public') return;
  rtdb.ref(`typing/${currentRoom}/${currentUser.uid}`).set(false);
});

// ===== DM desktop notifications + sound =====
function beep(kind='msg'){
  try {
    if (localStorage.getItem('soundNotifications') === 'false') return;
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = 'sine'; o.frequency.value = (kind==='ring' ? 660 : 880);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.2);
    o.connect(g); g.connect(ctx.destination); o.start(); o.stop(ctx.currentTime+0.22);
  } catch {}
}

function notifyDm(roomId, title, body){
  const desktopEnabled = localStorage.getItem('desktopNotifications') === 'true';
  if (!desktopEnabled || !('Notification' in window)) return;
  if (Notification.permission !== 'granted') return;
  const n = new Notification(title, { body, icon: '../logo.png', tag: `dm-${roomId}` });
  n.onclick = () => { try { window.focus(); switchRoom(roomId); } catch{} };
}

// Subtle two-tone ringtone loop for calls
let ringCtx = null;
let ringInterval = null;
function startRingtone(){
  if (localStorage.getItem('soundNotifications') === 'false') return;
  if (ringInterval) return;
  try { ringCtx = new (window.AudioContext||window.webkitAudioContext)(); } catch { return; }
  const playNote = (freq, dur=0.22, gain=0.18, type='sine', delay=0)=>{
    try {
      const o = ringCtx.createOscillator(); const g = ringCtx.createGain();
      o.type = type; o.frequency.value = freq; g.gain.value = 0.0001;
      o.connect(g); g.connect(ringCtx.destination);
      const t = ringCtx.currentTime + delay;
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(gain, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.start(t); o.stop(t+dur+0.02);
    } catch {}
  };
  // pattern: soft arpeggio + short tick
  const pattern = () => {
    playNote(740, 0.20, 0.16, 'sine', 0.00); // F#5
    playNote(659, 0.18, 0.14, 'sine', 0.22); // E5
    playNote(587, 0.18, 0.14, 'sine', 0.42); // D5
    playNote(880, 0.16, 0.12, 'triangle', 0.62); // A5 ping
    // soft low tick for texture
    playNote(180, 0.08, 0.08, 'sine', 0.80);
  };
  pattern();
  ringInterval = setInterval(pattern, 1300);
}
function stopRingtone(){
  if (ringInterval) { clearInterval(ringInterval); ringInterval=null; }
  if (ringCtx) { try { ringCtx.close(); } catch {} ringCtx=null; }
}

function cleanupDmNotificationWatchers(){
  Object.values(dmMsgWatchers).forEach(unsub=>{ try{unsub();}catch{} });
  dmMsgWatchers = {}; // do not reset dmMsgLastDocId to preserve last seen across reinit
}

function initDmNotificationWatchers(){
  cleanupDmNotificationWatchers();
  if (!currentUser || !Array.isArray(dmRooms)) return;
  dmRooms.forEach(room => {
    const q = db.collection('messages').where('room','==',room.id).orderBy('timestamp','desc').limit(1);
    dmMsgWatchers[room.id] = q.onSnapshot((snap)=>{
      if (snap.empty) return;
      const doc = snap.docs[0];
      if (dmMsgLastDocId[room.id] === doc.id) return; // ignore repeats
      dmMsgLastDocId[room.id] = doc.id;
      const m = doc.data();
      if (m.type==='system') return;
      if (!currentUser || m.uid === currentUser.uid) return;
      // only notify if message is not in the active room or tab not focused
      if (document.hidden || currentRoom !== room.id) {
        notifyDm(room.id, `${room.name} sent a message`, m.text || 'New message');
        beep('msg');
        unreadDMs[room.id] = true; renderRoomTabs();
      }
    });
  });
}

function cleanupGlobalCallWatchers(){
  Object.values(globalOfferWatchers).forEach(ref => { try{ ref.off(); }catch{} });
  globalOfferWatchers = {};
  Object.values(globalStateWatchers).forEach(ref => { try{ ref.off(); }catch{} });
  globalStateWatchers = {};
}

function initGlobalCallWatchers(){
  cleanupGlobalCallWatchers();
  if (!currentUser || !Array.isArray(dmRooms)) return;
  dmRooms.forEach(room => {
    const ref = rtdb.ref(`calls/${room.id}/offer`);
    ref.on('value', (s)=>{
      const v = s.val();
      if (!v) return;
      if (v.from === currentUser.uid) return;
      if (pc) return; // already on a call
      // if offer arrives in a different room than current, show modal
      if (room.id !== currentRoom) {
        const name = room.name.replace(/^@/, '');
        document.getElementById('incomingName').textContent = name;
        document.getElementById('incomingAvatar').textContent = (name[0]||'U').toUpperCase();
        incomingCallCtx = { roomId: room.id, offer: { type:v.type, sdp:v.sdp } };
        document.getElementById('incomingCallModal').classList.add('active');
        startRingtone();
        // temporary state watcher for this room to stop ring if caller cancels
        const sref = rtdb.ref(`calls/${room.id}/state`);
        sref.on('value', (sv)=>{
          const st = sv.val();
          if (st && st.state==='ended' && incomingCallCtx && incomingCallCtx.roomId===room.id) {
            document.getElementById('incomingCallModal').classList.remove('active');
            incomingCallCtx=null; stopRingtone();
          }
        });
        globalStateWatchers[room.id] = sref;
      }
    });
    globalOfferWatchers[room.id] = ref;
  });
}
// Draggable minimized call widget with snapping
(function initCallWidgetDrag(){
  const widget = document.getElementById('callWidget');
  if (!widget) return;
  let dragging=false, startX=0, startY=0, orig={x:0,y:0};
  function applyCorner(c){
    widget.style.top = widget.style.right = widget.style.bottom = widget.style.left = '';
    if (c==='tl'){ widget.style.top='80px'; widget.style.left='20px'; }
    if (c==='tr'){ widget.style.top='80px'; widget.style.right='20px'; }
    if (c==='bl'){ widget.style.bottom='20px'; widget.style.left='20px'; }
    if (c==='br'){ widget.style.bottom='20px'; widget.style.right='20px'; }
    localStorage.setItem('callWidgetCorner', c);
  }
  applyCorner(localStorage.getItem('callWidgetCorner')||'tl');
  function onDown(e){
    dragging=true; widget.style.transition='none'; widget.style.cursor='grabbing';
    const r=widget.getBoundingClientRect(); orig={x:r.left,y:r.top};
    startX=(e.touches?e.touches[0].clientX:e.clientX);
    startY=(e.touches?e.touches[0].clientY:e.clientY);
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchmove', onMove, {passive:false});
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchend', onUp);
    e.preventDefault();
  }
  function onMove(e){
    if(!dragging) return;
    const x=(e.touches?e.touches[0].clientX:e.clientX);
    const y=(e.touches?e.touches[0].clientY:e.clientY);
    const dx=x-startX, dy=y-startY;
    widget.style.left=(orig.x+dx)+'px'; widget.style.top=(orig.y+dy)+'px';
    widget.style.right=''; widget.style.bottom='';
  }
  function onUp(){
    if(!dragging) return; dragging=false;
    widget.style.transition='top .2s ease, left .2s ease, right .2s ease, bottom .2s ease'; widget.style.cursor='grab';
    const r=widget.getBoundingClientRect(); const vw=window.innerWidth, vh=window.innerHeight;
    const d={ tl:Math.hypot(r.left-20,r.top-80), tr:Math.hypot(vw-r.right-20,r.top-80), bl:Math.hypot(r.left-20,vh-r.bottom-20), br:Math.hypot(vw-r.right-20,vh-r.bottom-20)};
    const best=Object.entries(d).sort((a,b)=>a[1]-b[1])[0][0];
    applyCorner(best);
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mouseup', onUp);
    document.removeEventListener('touchend', onUp);
  }
  widget.addEventListener('mousedown', onDown);
  widget.addEventListener('touchstart', onDown, {passive:false});
})();
    
    function loadOnlineUsers() {
      db.collection('users').where('online', '==', true).onSnapshot((snapshot) => {
        const usersDiv = document.getElementById('usersList');
        usersDiv.innerHTML = '';

        snapshot.forEach((doc) => {
          const user = doc.data();
          if (user.showOnlineStatus === false) return; // respect privacy toggle
          const userEl = document.createElement('div');
          userEl.className = 'user-row';
          userEl.innerHTML = `
            <div>
              <div class="user-name">${user.username}${user.isAdmin ? '<span class="badge-admin">ADMIN</span>' : ''}</div>
              <div class="user-meta"><span class="status-dot online"></span>online</div>
            </div>
          `;
          userEl.addEventListener('click', () => showProfile(user));
          usersDiv.appendChild(userEl);
        });
      });
    }

    function showProfile(user) {
      document.getElementById('profileModal').classList.add('active');
      document.getElementById('profileAvatar').textContent = user.username[0].toUpperCase();
      document.getElementById('profileUsername').textContent = user.username;
      document.getElementById('profileStatus').textContent = user.online ? 'online' : 'offline';
      document.getElementById('profileBio').textContent = user.bio || 'no bio set';
    }

    document.getElementById('sendBtn').addEventListener('click', sendMessage);
    document.getElementById('messageInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); sendMessage(); }
  });

    // Attach menu + image/GIF/Poll handlers
    const attachBtn = document.getElementById('attachBtn');
    const attachDropdown = document.getElementById('attachDropdown');
    const imageInput = document.getElementById('imageInput');
    const attachedImages = document.getElementById('attachedImages');
    const imageModal = document.getElementById('imageModal');
    const imageModalImg = document.getElementById('imageModalImg');
    const imageModalCaption = document.getElementById('imageModalCaption');
    const imageModalClose = document.getElementById('imageModalClose');
    const imageModalSend = document.getElementById('imageModalSend');
    const imageModalCancel = document.getElementById('imageModalCancel');
    const imageModalRemove = document.getElementById('imageModalRemove');
    // GIF modal elements
    const gifModal = document.getElementById('gifModal');
    const gifSearchInput = document.getElementById('gifSearchInput');
    const gifResults = document.getElementById('gifResults');
    const gifCloseBtn = document.getElementById('gifCloseBtn');
    // Poll modal elements
    const pollModal = document.getElementById('pollModal');
    const pollQuestion = document.getElementById('pollQuestion');
    const pollOptions = document.getElementById('pollOptions');
    const addPollOptionBtn = document.getElementById('addPollOption');
    const createPollBtn = document.getElementById('createPollBtn');
    const pollCancelBtn = document.getElementById('pollCancelBtn');
    const pollError = document.getElementById('pollError');

  const API_BASE = (window.__ENV && window.__ENV.API_BASE) ? window.__ENV.API_BASE : 'https://api.wsgpolar.me';

    let attachedFile = null; // File object
    let attachedUrl = null;  // object URL for preview
    let attachedThumbEl = null;

    // Attach dropdown toggle
    function toggleAttachDropdown(show) {
      if (!attachDropdown) return;
      const visible = attachDropdown.style.display !== 'none';
      const want = typeof show === 'boolean' ? show : !visible;
      attachDropdown.style.display = want ? 'block' : 'none';
    }
    attachBtn && attachBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      toggleAttachDropdown();
    });
    // Handle dropdown actions
    attachDropdown && attachDropdown.addEventListener('click', (e)=>{
      const target = e.target.closest('button');
      if (!target) return;
      const action = target.getAttribute('data-action');
      if (action === 'upload') {
        toggleAttachDropdown(false);
        imageInput && imageInput.click();
      } else if (action === 'giphy') {
        toggleAttachDropdown(false);
        openGifModal();
      } else if (action === 'poll') {
        toggleAttachDropdown(false);
        openPollModal();
      }
    });
    document.addEventListener('click', (e)=>{
      if (!attachDropdown) return;
      if (e.target === attachBtn || attachDropdown.contains(e.target)) return;
      toggleAttachDropdown(false);
    });

    imageInput && imageInput.addEventListener('change', (e)=>{
      const file = (e.target.files && e.target.files[0]) || null;
      if (!file) return;
      if (!file.type.startsWith('image/')) { alert('Please select an image file.'); return; }
      // replace existing attachment (single-file support)
      clearAttachment();
      attachedFile = file;
      attachedUrl = URL.createObjectURL(file);
      // create thumbnail square
      const thumbWrap = document.createElement('div');
      thumbWrap.className = 'attachment-thumb';
      thumbWrap.style.width = '56px'; thumbWrap.style.height = '56px'; thumbWrap.style.borderRadius='8px'; thumbWrap.style.overflow='hidden'; thumbWrap.style.position='relative'; thumbWrap.style.border='1px solid var(--border)'; thumbWrap.style.cursor='pointer';
      const img = document.createElement('img');
      img.src = attachedUrl; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover';
      thumbWrap.appendChild(img);
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-attachment';
      removeBtn.textContent = '✕';
      removeBtn.style.position='absolute'; removeBtn.style.top='4px'; removeBtn.style.right='4px'; removeBtn.style.background='rgba(0,0,0,0.6)'; removeBtn.style.color='#fff'; removeBtn.style.border='none'; removeBtn.style.borderRadius='50%'; removeBtn.style.width='20px'; removeBtn.style.height='20px'; removeBtn.style.cursor='pointer';
      thumbWrap.appendChild(removeBtn);
      attachedImages.appendChild(thumbWrap);
      attachedThumbEl = thumbWrap;

      // click opens modal for full preview and caption
      thumbWrap.addEventListener('click', (ev)=>{ if (ev.target === removeBtn) return; openImageModal(); });
      removeBtn.addEventListener('click', (ev)=>{ ev.stopPropagation(); clearAttachment(); });
    });

    function clearAttachment(){
      if (attachedThumbEl && attachedThumbEl.parentNode) attachedThumbEl.parentNode.removeChild(attachedThumbEl);
      attachedThumbEl = null;
      if (attachedUrl) { try{ URL.revokeObjectURL(attachedUrl); }catch{} attachedUrl = null; }
      attachedFile = null;
      if (imageInput) imageInput.value = '';
    }


    function openImageModal(){
      if (!attachedFile || !attachedUrl) return;
      imageModalImg.src = attachedUrl;
      imageModalCaption.value = '';
      imageModal.classList.add('active');
    }

    function closeImageModal(){ imageModal.classList.remove('active'); }

    imageModalClose.addEventListener('click', ()=> closeImageModal());
    imageModalCancel.addEventListener('click', ()=> closeImageModal());

    // close when clicking the overlay/background
    imageModal.addEventListener('click', (e)=>{ if (e.target === imageModal) closeImageModal(); });

    imageModalRemove.addEventListener('click', ()=>{ if (!confirm('Remove this attachment?')) return; clearAttachment(); closeImageModal(); });

    imageModalSend.addEventListener('click', async ()=>{
      // Upload and send (with UI lock + spinner)
      if (!attachedFile) { alert('No image attached'); return; }
      const caption = (imageModalCaption.value || '').trim();
      setUploading(true);
      try {
        const url = await uploadImageToHost(attachedFile);
        if (!url) throw new Error('Upload failed');
        if (settings.chatShutdown) { alert('Chat is shut down by an admin.'); return; }
        if (settings.lockdown && !currentUser?.isAdmin) { alert('Chat is in lockdown.'); return; }
        const messageData = {
          uid: currentUser.uid,
          username: currentUser.username,
          isAdmin: !!currentUser.isAdmin,
          text: caption || '',
          type: 'image',
          imageUrl: url,
          room: currentRoom,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };
  await db.collection('messages').add(messageData);
  // force stick-to-bottom on media send
  autoScroll = true;
  scrollToBottom();
        clearAttachment();
        closeImageModal();
      } catch (err) {
        console.error('Image upload failed', err); alert('Image upload failed');
      } finally {
        setUploading(false);
      }
    });

  // --- GIF modal logic ---
  let giphyQuery = '';
  let giphyOffset = 0;
  let giphyLoading = false;
  let giphyHasMore = true;
  let gifObserver = null;
  let gifSentinel = null;

    function openGifModal(){
      gifModal.classList.add('active');
      gifSearchInput.value = giphyQuery || '';
      if (!gifResults.dataset.boot) {
        // boot once
        // scroll fallback
        gifResults.addEventListener('scroll', async ()=>{
          if (giphyLoading || !giphyHasMore) return;
          if (gifResults.scrollTop + gifResults.clientHeight >= gifResults.scrollHeight - 120) {
            await loadMoreGifs();
          }
        });
        // intersection observer sentinel for continuous load
        gifSentinel = document.createElement('div');
        gifSentinel.style.width = '100%';
        gifSentinel.style.height = '1px';
        gifSentinel.id = 'gifSentinel';
        gifResults.appendChild(gifSentinel);
        gifObserver = new IntersectionObserver(async (entries)=>{
          const entry = entries[0];
          if (entry && entry.isIntersecting && !giphyLoading && giphyHasMore) {
            await loadMoreGifs();
          }
        }, { root: gifResults, rootMargin: '200px', threshold: 0 });
        gifObserver.observe(gifSentinel);
        gifResults.dataset.boot = '1';
      }
      // always kick off a load for the current or default query
      performGifSearch(gifSearchInput.value.trim() || 'trending');
      setTimeout(()=> gifSearchInput.focus(), 50);
    }
    function closeGifModal(){ gifModal.classList.remove('active'); }
    gifCloseBtn.addEventListener('click', closeGifModal);
    gifModal.addEventListener('click', (e)=>{ if (e.target === gifModal) closeGifModal(); });
    gifSearchInput.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter') {
        performGifSearch(gifSearchInput.value.trim());
      }
    });
    async function performGifSearch(q){
      const query = q || 'trending';
      giphyQuery = query;
      giphyOffset = 0; giphyHasMore = true;
      gifResults.innerHTML = '';
      // ensure sentinel exists and is last
      if (!gifSentinel) { gifSentinel = document.createElement('div'); gifSentinel.style.width='100%'; gifSentinel.style.height='1px'; gifSentinel.id='gifSentinel'; }
      gifResults.appendChild(gifSentinel);
      gifResults.dataset.loaded = '1';
      await loadMoreGifs();
    }
    async function loadMoreGifs(){
      if (giphyLoading || !giphyHasMore) return;
      giphyLoading = true;
      try {
  const params = new URLSearchParams({ q: giphyQuery, limit: '36', offset: String(giphyOffset) });
        if (window.__ENV && window.__ENV.GIPHY_API_KEY) params.set('apiKey', window.__ENV.GIPHY_API_KEY);
        const resp = await fetch(`${API_BASE}/v1/giphy/search?${params.toString()}`);
        if (!resp.ok) throw new Error('giphy search failed');
        const data = await resp.json();
        const results = data.results || data.data || [];
        if (!results.length) { giphyHasMore = false; return; }
        giphyOffset = (data.nextOffset != null) ? data.nextOffset : (giphyOffset + results.length);
        for (const g of results) {
          const tile = document.createElement('div');
          tile.style.cursor='pointer'; tile.style.borderRadius='8px'; tile.style.overflow='hidden'; tile.style.border='1px solid var(--border)'; tile.title = g.title || '';
          // Masonry via CSS columns
          tile.style.display = 'inline-block';
          tile.style.width = '100%';
          tile.style.margin = '0 0 8px';
          const img = document.createElement('img');
          img.src = g.preview || g.url; img.alt = g.title || 'gif'; img.style.width='100%'; img.style.height='auto';
          tile.appendChild(img);
          tile.addEventListener('click', async ()=>{
            await sendGifMessage(g.url);
            closeGifModal();
          });
          gifResults.appendChild(tile);
        }
        // keep sentinel last
        if (gifSentinel && gifSentinel.parentNode !== gifResults) gifResults.appendChild(gifSentinel);
        else if (gifSentinel) gifResults.appendChild(gifSentinel);
      } catch (e) {
        console.error('giphy error', e);
        if (gifResults && !gifResults.childElementCount) {
          const msg = document.createElement('div');
          msg.style.color = '#f66'; msg.style.padding = '8px';
          msg.textContent = 'GIF search is unavailable right now. Ask an admin to set GIPHY_API_KEY or provide it in window.__ENV.GIPHY_API_KEY.';
          gifResults.appendChild(msg);
        }
      } finally {
        giphyLoading = false;
      }
    }
    async function sendGifMessage(url){
      if (!currentUser) { alert('Sign in to chat.'); return; }
      if (settings.chatShutdown) { alert('Chat is shut down by an admin.'); return; }
      if (settings.lockdown && !currentUser.isAdmin) { alert('Chat is in lockdown.'); return; }
      const meDoc = await db.collection('users').doc(currentUser.uid).get();
      const me = meDoc.exists ? meDoc.data() : currentUser;
      if (me.isBanned) { document.getElementById('banModal').classList.add('active'); document.getElementById('banReason').textContent = me.banReason || 'You have been banned from chat.'; await auth.signOut(); return; }
      if (me.isMuted) { alert('You are muted.'); return; }
      const messageData = {
        uid: currentUser.uid,
        username: currentUser.username,
        isAdmin: !!currentUser.isAdmin,
        type: 'gif',
        gifUrl: url,
        room: currentRoom,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      };
      if (replyingTo) { messageData.replyTo = replyingTo; replyingTo = null; document.getElementById('replyIndicator').classList.remove('active'); }
      await db.collection('messages').add(messageData);
      autoScroll = true;
      scrollToBottom();
    }

    // --- Poll modal logic ---
    function openPollModal(){
      pollQuestion.value = '';
      pollOptions.innerHTML = '';
      pollError.style.display = 'none';
      addOptionInput('');
      addOptionInput('');
      pollModal.classList.add('active');
      setTimeout(()=> pollQuestion.focus(), 50);
    }
    function closePollModal(){ pollModal.classList.remove('active'); }
    pollCancelBtn.addEventListener('click', closePollModal);
    pollModal.addEventListener('click', (e)=>{ if (e.target === pollModal) closePollModal(); });
    function addOptionInput(v=''){
      const row = document.createElement('div');
      row.style.display='flex'; row.style.gap='.5rem'; row.style.marginBottom='.5rem';
      const inp = document.createElement('input'); inp.placeholder = 'option'; inp.value = v;
      const rem = document.createElement('button'); rem.type='button'; rem.className='btn'; rem.textContent='remove';
      rem.addEventListener('click', ()=>{ row.remove(); });
      row.appendChild(inp); row.appendChild(rem);
      pollOptions.appendChild(row);
    }
    addPollOptionBtn.addEventListener('click', ()=> addOptionInput(''));
    createPollBtn.addEventListener('click', async ()=>{
      if (!currentUser) { alert('Sign in to chat.'); return; }
      const q = pollQuestion.value.trim();
      const opts = Array.from(pollOptions.querySelectorAll('input')).map(i=>i.value.trim()).filter(Boolean);
      if (!q || opts.length < 2) {
        pollError.textContent = 'Enter a question and at least two options.';
        pollError.style.display = 'block';
        return;
      }
      try{
        const resp = await fetch(`${API_BASE}/v1/polls`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ question:q, options:opts }) });
        if (!resp.ok) { const t = await resp.text(); throw new Error(t||'poll create failed'); }
        const data = await resp.json();
        await db.collection('messages').add({
          uid: currentUser.uid,
          username: currentUser.username,
          isAdmin: !!currentUser.isAdmin,
          type: 'poll',
          pollId: data.id,
          room: currentRoom,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        closePollModal();
      } catch (e) {
        console.error('poll create error', e);
        pollError.textContent = 'Failed to create poll.';
        pollError.style.display = 'block';
      }
    });

    async function uploadImageToHost(file){
      const base = 'https://api.wsgpolar.me/v1/images';
      // Try raw binary POST (example curl shows this form). Some endpoints expect a trailing slash.
      try {
        try {
          const buf = await file.arrayBuffer();
          const rawResp = await fetch(base + '/', {
            method: 'POST',
            headers: { 'Content-Type': file.type || 'application/octet-stream' },
            body: buf
          });
          if (rawResp.ok) {
            // try parse JSON, otherwise treat text as URL
            try {
              const json = await rawResp.json();
              return json?.url || json?.data?.url || json?.imageUrl || json?.result?.url || null;
            } catch (err) {
              const txt = (await rawResp.text()).trim();
              if (/^https?:\/\//.test(txt)) return txt;
            }
          } else if (rawResp.status !== 404) {
            // non-404 but failed; try to log body for debugging
            const txt = await rawResp.text();
            console.warn('Raw upload response', rawResp.status, txt);
          }
        } catch (errRaw) {
          console.warn('Raw binary upload failed, will try multipart fallback', errRaw);
        }

        // Fallback to multipart/form-data POST (older behavior)
        const fd = new FormData();
        fd.append('file', file, file.name || 'upload');
        const resp = await fetch(base, { method: 'POST', body: fd });
        if (!resp.ok) { console.error('Multipart upload response not ok', resp.status); try { const t = await resp.text(); console.error(t); } catch{} return null; }
        // try parse JSON
        try {
          const json = await resp.json();
          return json?.url || json?.data?.url || json?.imageUrl || json?.result?.url || null;
        } catch (e) {
          const txt = (await resp.text()).trim();
          if (/^https?:\/\//.test(txt)) return txt;
          return null;
        }
      } catch (e) { console.error('uploadImageToHost error', e); return null; }
    }

    // UI helper to show uploading state (spinner + disable inputs)
    function setUploading(flag){
      const spinner = document.getElementById('uploadSpinner');
      const sendBtnEl = document.getElementById('sendBtn');
      const attachBtnEl = document.getElementById('attachBtn');
      const modalSend = document.getElementById('imageModalSend');
      const modalRemove = document.getElementById('imageModalRemove');
      const modalCancel = document.getElementById('imageModalCancel');
      const inputEl = document.getElementById('messageInput');
      if (spinner) spinner.style.display = flag ? 'block' : 'none';
      if (sendBtnEl) sendBtnEl.disabled = !!flag;
      if (attachBtnEl) attachBtnEl.disabled = !!flag;
      if (modalSend) modalSend.disabled = !!flag;
      if (modalRemove) modalRemove.disabled = !!flag;
      if (modalCancel) modalCancel.disabled = !!flag;
      if (inputEl) inputEl.disabled = !!flag;
    }

    async function sendMessage() {
  const input = document.getElementById('messageInput');
  const textRaw = (input.value || '');
  const text = textRaw.trim();
  if (!currentUser) { alert('Sign in to chat.'); return; }

  // If no text but there is an attached image, upload & send it
  if (!text && attachedFile) {
    // Respect global switches
    if (settings.chatShutdown) { alert('Chat is shut down by an admin.'); return; }
    if (settings.lockdown && !currentUser.isAdmin) { alert('Chat is in lockdown.'); return; }

    // Fresh read of user record
    const meDoc = await db.collection('users').doc(currentUser.uid).get();
    const me = meDoc.exists ? meDoc.data() : currentUser;
    if (me.isBanned) {
      document.getElementById('banModal').classList.add('active');
      document.getElementById('banReason').textContent = me.banReason || 'You have been banned from chat.';
      await auth.signOut();
      return;
    }

    if (me.isMuted) {
      const untilMs = typeof me.muteUntil === 'number' ? me.muteUntil : (me.muteUntil && typeof me.muteUntil.toMillis === 'function' ? me.muteUntil.toMillis() : 0);
      const remaining = untilMs ? Math.max(0, Math.ceil((untilMs - Date.now()) / 1000)) : null;
      alert(remaining ? `You are muted for ${remaining} more second(s).` : 'You are muted.');
      return;
    }

    // perform upload
    try {
      setUploading(true);
      const url = await uploadImageToHost(attachedFile);
      if (!url) throw new Error('Upload failed');
      const caption = (document.getElementById('imageModalCaption')?.value || '').trim();
      const messageData = {
        uid: currentUser.uid,
        username: currentUser.username,
        isAdmin: !!currentUser.isAdmin,
        text: caption || '',
        type: 'image',
        imageUrl: url,
        room: currentRoom,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      };
      if (replyingTo) { messageData.replyTo = replyingTo; replyingTo = null; document.getElementById('replyIndicator').classList.remove('active'); }
      await db.collection('messages').add(messageData);
      // bookkeeping
      const nowLocal = nowMs();
      settings.lastSentAt = nowLocal;
      lastMessage = '[image]';
      lastMessageTime = nowLocal;
      clearAttachment();
      input.value = '';
      setUploading(false);
      autoScroll = true;
      scrollToBottom();
    } catch (err) {
      console.error('Image upload/send failed', err);
      alert('Failed to send image.');
      setUploading(false);
    }
    return;
  }

  // Admin commands first (should work even during shutdown/lockdown)
  if (text.startsWith('/') && !!currentUser.isAdmin) {
    await handleAdminCommand(text);
    input.value = '';
    return;
  }

  // Global switches
  if (settings.chatShutdown) { alert('Chat is shut down by an admin.'); return; }
  if (settings.lockdown && !currentUser.isAdmin) { alert('Chat is in lockdown.'); return; }

  // Fresh read of user record to avoid stale state
  const meDoc = await db.collection('users').doc(currentUser.uid).get();
  const me = meDoc.exists ? meDoc.data() : currentUser;

  if (me.isBanned) {
    document.getElementById('banModal').classList.add('active');
    document.getElementById('banReason').textContent = me.banReason || 'You have been banned from chat.';
    await auth.signOut();
    return;
  }

  if (me.isMuted) {
    const untilMs = typeof me.muteUntil === 'number' ? me.muteUntil : (me.muteUntil && typeof me.muteUntil.toMillis === 'function' ? me.muteUntil.toMillis() : 0);
    const remaining = untilMs ? Math.max(0, Math.ceil((untilMs - Date.now()) / 1000)) : null;
    alert(remaining ? `You are muted for ${remaining} more second(s).` : 'You are muted.');
    return;
  }

  if (!text) return; // Nothing to send

  // Content checks
  if (containsOffensive(text)) { alert('Message blocked by content filter.'); return; }

  // Slow mode (per device, backed by RTDB setting)
  if (settings.slowMode > 0 && !me.isAdmin) {
    const elapsed = (nowMs() - (settings.lastSentAt || 0)) / 1000;
    if (elapsed < settings.slowMode) {
      alert(`Slow mode is on. Wait ${Math.ceil(settings.slowMode - elapsed)}s.`);
      return;
    }
  }

  // Simple anti-spam: identical message within 3s
  const nowLocal = nowMs();
  if (text === lastMessage && (nowLocal - lastMessageTime) < 3000) {
    alert('Please do not spam the same message.');
    return;
  }

  // Build & send message with serverTimestamp (authoritative ordering)
  const messageData = {
    uid: currentUser.uid,
    username: currentUser.username,
    isAdmin: !!currentUser.isAdmin,
    text,
    room: currentRoom,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  };

  if (replyingTo) {
    messageData.replyTo = replyingTo;
    replyingTo = null;
    document.getElementById('replyIndicator').classList.remove('active');
  }

  await db.collection('messages').add(messageData);

  // Local bookkeeping
  settings.lastSentAt = nowLocal;
  lastMessage = text;
  lastMessageTime = nowLocal;
  input.value = '';
  // stick to bottom after sending
  autoScroll = true;
  scrollToBottom();
}

    async function handleAdminCommand(command) {
      const parts = command.split(' ');
      const cmd = parts[0].toLowerCase();
      const args = parts.slice(1);

      console.log('[v0] Admin command:', cmd, args);

      try {
        switch(cmd) {
          case '/ban':
            if (args.length < 1) {
              alert('Usage: /ban <username> [reason]');
              return;
            }
            await banUser(args[0], args.slice(1).join(' ') || 'No reason provided');
            break;

          case '/unban':
            if (args.length < 1) {
              alert('Usage: /unban <username>');
              return;
            }
            await unbanUser(args[0]);
            break;

          case '/kick':
            if (args.length < 1) {
              alert('Usage: /kick <username>');
              return;
            }
            await kickUser(args[0]);
            break;

          case '/mute':
            if (args.length < 2) {
              alert('Usage: /mute <username> <minutes>');
              return;
            }
            await muteUser(args[0], parseInt(args[1]));
            break;

          case '/unmute':
            if (args.length < 1) {
              alert('Usage: /unmute <username>');
              return;
            }
            await unmuteUser(args[0]);
            break;

          case '/clear':
            await clearChat();
            break;

          case '/announce':
            if (args.length < 1) {
              alert('Usage: /announce <message>');
              return;
            }
            await sendAnnouncement(args.join(' '));
            break;

          case '/warn':
            if (args.length < 2) {
              alert('Usage: /warn <username> <message>');
              return;
            }
            await warnUser(args[0], args.slice(1).join(' '));
            break;

          case '/promote':
            if (args.length < 1) {
              alert('Usage: /promote <username>');
              return;
            }
            await promoteUser(args[0]);
            break;

          case '/demote':
            if (args.length < 1) {
              alert('Usage: /demote <username>');
              return;
            }
            await demoteUser(args[0]);
            break;

          case '/shutdown':
            await shutdownChat();
            break;

          case '/restart':
            await restartChat();
            break;

          case '/slowmode':
            if (args.length < 1) {
              alert('Usage: /slowmode <seconds>');
              return;
            }
            await setSlowMode(parseInt(args[0]));
            break;

          case '/lockdown':
            await toggleLockdown();
            break;

          case '/purge':
            if (args.length < 1) {
              alert('Usage: /purge <username>');
              return;
            }
            await purgeUserMessages(args[0]);
            break;

          case '/stats':
            await showStats();
            break;

          case '/help':
            showAdminHelp();
            break;

          default:
            alert(`Unknown command: ${cmd}\nType /help for a list of commands`);
        }
      } catch (error) {
        console.error('[v0] Command error:', error);
        alert(`Error executing command: ${error.message}`);
      }
    }

    // Admin utilities: gate all admin actions behind Firestore doc isAdmin
    function ensureAdmin(){
      if (!currentUser || currentUser.isAdmin !== true) {
        alert('Admin only.');
        return false;
      }
      return true;
    }

    async function banUser(username, reason) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({
        isBanned: true,
        banReason: reason,
        bannedBy: currentUser.username,
        bannedAt: Date.now()
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been banned by ${currentUser.username}. Reason: ${reason}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been banned`);
    }

    async function unbanUser(username) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({
        isBanned: false,
        banReason: null,
        bannedBy: null,
        bannedAt: null
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been unbanned by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been unbanned`);
    }

    async function kickUser(username) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({ online: false });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been kicked by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been kicked`);
    }

    async function muteUser(username, minutes) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      const muteUntil = Date.now() + (minutes * 60 * 1000);
      
      await db.collection('users').doc(userDoc.id).update({
        isMuted: true,
        muteUntil: muteUntil,
        mutedBy: currentUser.username
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been muted for ${minutes} minutes by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been muted for ${minutes} minutes`);
    }

    async function unmuteUser(username) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({
        isMuted: false,
        muteUntil: null,
        mutedBy: null
      });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been unmuted by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been unmuted`);
    }

    async function clearChat() {
      if (!ensureAdmin()) return;
      const messagesQuery = await db.collection('messages').where('room', '==', currentRoom).get();
      const batch = db.batch();
      messagesQuery.docs.forEach(doc => batch.delete(doc.ref));
      await batch.commit();

      await db.collection('messages').add({
        type: 'system',
        text: `Chat cleared by ${currentUser.username}`,
        room: currentRoom,
        timestamp: Date.now()
      });

      alert('Chat has been cleared');
    }

    async function sendAnnouncement(message) {
      if (!ensureAdmin()) return;
      await db.collection('messages').add({
        type: 'system',
        text: `📢 ANNOUNCEMENT: ${message}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert('Announcement sent');
    }

    async function warnUser(username, message) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      await db.collection('messages').add({
        type: 'system',
        text: `⚠️ ${username} has been warned by ${currentUser.username}: ${message}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`Warning sent to ${username}`);
    }

    async function promoteUser(username) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({ isAdmin: true });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been promoted to admin by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been promoted to admin`);
    }

    async function demoteUser(username) {
      if (!ensureAdmin()) return;
      const userQuery = await db.collection('users').where('username', '==', username).get();
      if (userQuery.empty) {
        alert('User not found');
        return;
      }

      const userDoc = userQuery.docs[0];
      await db.collection('users').doc(userDoc.id).update({ isAdmin: false });

      await db.collection('messages').add({
        type: 'system',
        text: `${username} has been demoted by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`${username} has been demoted`);
    }

    async function shutdownChat() {
      if (!ensureAdmin()) return;
      await db.collection('settings').doc('chat').set({ chatShutdown: true }, { merge: true });
      
      await db.collection('messages').add({
        type: 'system',
        text: `🔒 Chat has been shut down by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert('Chat has been shut down');
    }

    async function restartChat() {
      if (!ensureAdmin()) return;
      await db.collection('settings').doc('chat').set({ chatShutdown: false }, { merge: true });
      
      await db.collection('messages').add({
        type: 'system',
        text: `✅ Chat has been restarted by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert('Chat has been restarted');
    }

    async function setSlowMode(seconds) {
      if (!ensureAdmin()) return;
      await db.collection('settings').doc('chat').set({ slowMode: seconds }, { merge: true });
      
      await db.collection('messages').add({
        type: 'system',
        text: `⏱️ Slow mode set to ${seconds} seconds by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`Slow mode set to ${seconds} seconds`);
    }

    async function toggleLockdown() {
      if (!ensureAdmin()) return;
      const settingsRef = db.collection('settings').doc('chat');
      let newState = false;
      await db.runTransaction(async (tx) => {
        const snap = await tx.get(settingsRef);
        const cur = snap.exists && snap.data().lockdown === true;
        newState = !cur;
        tx.set(settingsRef, { lockdown: newState }, { merge: true });
      });
      
      await db.collection('messages').add({
        type: 'system',
        text: `🔐 Lockdown ${!isLocked ? 'enabled' : 'disabled'} by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

  alert(`Lockdown ${newState ? 'enabled' : 'disabled'}`);
    }

    async function purgeUserMessages(username) {
      if (!ensureAdmin()) return;
      const messagesQuery = await db.collection('messages').where('username', '==', username).get();
      const batch = db.batch();
      messagesQuery.docs.forEach(doc => batch.delete(doc.ref));
      await batch.commit();

      await db.collection('messages').add({
        type: 'system',
        text: `All messages from ${username} have been purged by ${currentUser.username}`,
        room: 'public',
        timestamp: Date.now()
      });

      alert(`All messages from ${username} have been purged`);
    }

    async function showStats() {
      if (!ensureAdmin()) return;
      const usersSnapshot = await db.collection('users').get();
      const messagesSnapshot = await db.collection('messages').get();
      const onlineUsers = usersSnapshot.docs.filter(doc => doc.data().online).length;
      
      alert(`
📊 Chat Statistics:
Total Users: ${usersSnapshot.size}
Online Users: ${onlineUsers}
Total Messages: ${messagesSnapshot.size}
Current Room: ${currentRoom}
      `);
    }

    function showAdminHelp() {
      alert(`
🛠️ Admin Commands:
/ban <user> [reason] - Ban a user
/unban <user> - Unban a user
/kick <user> - Kick a user
/mute <user> <minutes> - Mute a user
/unmute <user> - Unmute a user
/warn <user> <message> - Warn a user
/promote <user> - Promote to admin
/demote <user> - Demote from admin
/clear - Clear chat messages
/purge <user> - Delete all user messages
/announce <message> - Send announcement
/slowmode <seconds> - Set slow mode
/lockdown - Toggle lockdown mode
/shutdown - Shutdown chat
/restart - Restart chat
/stats - Show statistics
/help - Show this help
      `);
    }

    window.addEventListener('beforeunload', () => {
      if (currentUser) {
        db.collection('users').doc(currentUser.uid).update({ online: false });
      }
    });

    document.getElementById('showSignUpBtn').addEventListener('click', () => {
      document.getElementById('signInForm').style.display = 'none';
      document.getElementById('signUpForm').style.display = 'block';
    });

    document.getElementById('showSignInBtn').addEventListener('click', () => {
      document.getElementById('signUpForm').style.display = 'none';
      document.getElementById('signInForm').style.display = 'block';
    });
    
    // Clean up any active call when leaving the page
    window.addEventListener('beforeunload', () => {
      if (pc) {
        try { endCall('unload'); } catch {}
      }
    });
  </script>
</body>
</html>
